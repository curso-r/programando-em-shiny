[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programando em Shiny",
    "section": "",
    "text": "Boas-vindas!\nEste é um livro em desenvolvimento. Toda contribuição, seja correção de erros ortográficos ou sugestões de novos conteúdos, será bem-vinda. Você pode contribuir criando issues nesse repositório.\nO conteúdo aqui presente se destina a:",
    "crumbs": [
      "Boas-vindas!"
    ]
  },
  {
    "objectID": "index.html#o-que-é-shiny",
    "href": "index.html#o-que-é-shiny",
    "title": "Programando em Shiny",
    "section": "O que é Shiny?",
    "text": "O que é Shiny?\nShiny é um framework em linguagem R para a criação de aplicativos web. Por não exigir conhecimento prévio de HTML, CSS e JavaScript, ele democratiza o acesso a essa área de desenvolvimento, permitindo a criação de aplicativos bonitos e complexos a partir de um script R.",
    "crumbs": [
      "Boas-vindas!"
    ]
  },
  {
    "objectID": "index.html#por-que-aprender-shiny",
    "href": "index.html#por-que-aprender-shiny",
    "title": "Programando em Shiny",
    "section": "Por que aprender Shiny?",
    "text": "Por que aprender Shiny?\nPor ser gratuito e por não exigir de largada conhecimento em desenvolvimento Web, o framework Shiny vem sendo cada vez mais utilizado por empresas e por órgãos do governo para acomodar painéis analíticos ou para comunicar resultados de maneira interativa e dinâmica. Programar em Shiny se tornou um grande diferencial para cientistas de dados.\nNas universidades, o Shiny já é uma poderosa ferramenta de ensino, que substitui apresentações de dezenas de slides por apenas uma única tela interativa. Também é muito útil para a explicação de conceitos estatísticos, além de incentivar estudantes a programar. Na pesquisa, o Shiny facilita a colaboração entre cientistas de diferentes áreas e é uma excelente alternativa para aumentar e melhorar a comunicação científica.",
    "crumbs": [
      "Boas-vindas!"
    ]
  },
  {
    "objectID": "index.html#quais-são-os-limites-do-shiny",
    "href": "index.html#quais-são-os-limites-do-shiny",
    "title": "Programando em Shiny",
    "section": "Quais são os limites do Shiny?",
    "text": "Quais são os limites do Shiny?\nO Shiny fornece uma estrutura para gerarmos código HTML a partir de funções em R. Também possui uma base de JavaScript e CSS para deixar os aplicativos funcionais e com um visual satisfatório. Além disso, podemos utilizar por trás todo o poderio de análise de dados que o R e seus pacotes fornecem. Com esses elementos, já conseguimos construir qualquer tipo de layout e lógica interna.\nContudo, o grande poder do Shiny está em não limitar as possibilidades apenas ao que foi feito pelos desenvolvedores do pacote1. Existem vários outros pacotes criados pela comunidade que trazem mais elementos visuais e funcionais para o Shiny, diminuindo ainda mais a necessidade de conhecermos HTML, CSS e JavaScript. E, se você tem conhecimento dessas linguagens, o céu é o limite! É muito simples incluir tags HTML, folhas de estilo CSS e suas próprias funções JavaScript em um aplicativo Shiny.",
    "crumbs": [
      "Boas-vindas!"
    ]
  },
  {
    "objectID": "index.html#o-que-você-vai-aprender-neste-livro",
    "href": "index.html#o-que-você-vai-aprender-neste-livro",
    "title": "Programando em Shiny",
    "section": "O que você vai aprender neste livro?",
    "text": "O que você vai aprender neste livro?\nPor possuir um paradigma de programação diferente do que estamos acostumados no R, o Shiny não é o assunto mais indicado para quem está começando a estudar a linguagem. Se você é uma pessoa iniciante em R, recomendamos ficar bem confortável com alguns conceitos base antes de embarcar no Shiny.\nEm específico, este livro assume que você já tem conhecimento de construção de funções, do operador pipe (%&gt;% ou |&gt;) e dos principais pacotes do tidyverse (readr, dplyr, tidyr,ggplot2, stringr e lubridate). Se esses temas não são familiares para você, indicamos a leitura do livro Ciência de Dados em R antes de prosseguir.\nSe você já programa em R e gostaria de começar a programar em Shiny, você deve iniciar a leitura pela Parte 1. Você irá aprender,\n\ncomo construir interfaces de usuário (UI);\ncomo construir a lógica interna do app (server);\no que é e como lidar com a reatividade;\naplicar alguns tipos de layout ao seu app;\ncomo utilizar htmlwidgets.\n\nSe você já programa em Shiny e gostaria de se aprofundar no tema, você pode iniciar na Parte 2. A partir desse ponto, vamos\n\nutilizar módulos e o framework golem para organizar a construção de aplicativos complexos;\naprender uma base de HTML, CSS e JavaScript para começar a desenvolver seu próprio layout e funcionalidades;\nexplorar problemas complexos de reatividade para permitir interações ainda mais finas entre o usuário e o aplicativo.",
    "crumbs": [
      "Boas-vindas!"
    ]
  },
  {
    "objectID": "index.html#como-tirar-o-melhor-proveito-deste-livro",
    "href": "index.html#como-tirar-o-melhor-proveito-deste-livro",
    "title": "Programando em Shiny",
    "section": "Como tirar o melhor proveito deste livro",
    "text": "Como tirar o melhor proveito deste livro\nFalar sobre Shiny em texto um grande desafio. A maior parte dos resultados que vamos apresentar são interativos e dependem de um servidor para funcionar, o que torna difícil descrevê-los ou representá-los com imagens.\nDeixamos alguns poucos aplicativos utilizados como exemplo neste livro online2. Sempre que disponível, recomendamos acessar o link e interagir com o app.\nNo restante dos casos, deixamos disponível junto ao texto o código completo do app, que você pode copiar e colar no R para rodar o aplicativo. Recomendamos que você faça isso para todos os exemplos deste tipo, sempre fazendo o exercício de analisar qual parte do código gera cada parte do app.",
    "crumbs": [
      "Boas-vindas!"
    ]
  },
  {
    "objectID": "index.html#o-que-eu-preciso-para-começar-a-aprender-shiny",
    "href": "index.html#o-que-eu-preciso-para-começar-a-aprender-shiny",
    "title": "Programando em Shiny",
    "section": "O que eu preciso para começar a aprender Shiny?",
    "text": "O que eu preciso para começar a aprender Shiny?\nAntes de mais nada, participe das comunidades! Compartilhe seu desenvolvimento. Poste seus avanços nas redes sociais e compartilhe suas dúvidas em fóruns. You’ll never walk alone3.\n\nComunidade RLadies\nFórum de dúvidas da Curso-R\nAI inclusive\nGrupo Shiny Brasil no Telegram\nGrupo R Brasil no Telegram\n\nVocê também precisará:\n\nconhecimento básico de R (ver seção anterior);\ncomputador com últimas versões do R e do RStudio instaladas;\nacesso à internet.",
    "crumbs": [
      "Boas-vindas!"
    ]
  },
  {
    "objectID": "index.html#footnotes",
    "href": "index.html#footnotes",
    "title": "Programando em Shiny",
    "section": "",
    "text": "O que já é muita coisa! Veja mais em https://shiny.rstudio.com/.↩︎\nInfelizmente seria muito trabalhoso e caro fazer isso com todos.↩︎\nVocê nunca andará sozinha/sozinho, lema do Liverpool Football Club, um dos times mais populares da Inglaterra. A frase teve origem na música de mesmo nome composta por Richard Rodgers e Oscar Hammerstein em 1945, considerada hino do clube inglês.↩︎",
    "crumbs": [
      "Boas-vindas!"
    ]
  },
  {
    "objectID": "sobre.html",
    "href": "sobre.html",
    "title": "Sobre este livro",
    "section": "",
    "text": "Este livro foi escrito em R Markdown, com o pacote bookdown, e está em construção e em revisão aberta. Fique à vontade para corrigir qualquer tipo de erro que encontrar criando issues neste repositório.\nO texto deste livro foi elaborado por William Amorim com colaboração do time da Curso-R. Ele está disponível gratuitamente no Github sob a licença GNU GPLv3.\nA Curso-R é o braço de Educação da R6 Consultoria, uma empresa de treinamentos e consultoria em Ciência de Dados e linguagem de programação R.\n\nConheça os cursos da Curso-R\nConheça o blog da Curso-R\nConheça os outros livros elaborados pela equipe da Curso-R:\n\nCiência de Dados em R\nZen do R\n\n\nParticiparam da construção deste livro:\n\nAthos Damiani\nCaio Lente\nDaniel Falbel\nFernando Correa\nJulio Tricenti\nWilliam Amorim",
    "crumbs": [
      "Sobre este livro"
    ]
  },
  {
    "objectID": "primeiro-app.html",
    "href": "primeiro-app.html",
    "title": "1  Seu primeiro aplicativo Shiny",
    "section": "",
    "text": "1.1 O que é um aplicativo Shiny?\nNa tentativa de explicar o que é um aplicativo Shiny, podemos reduzi-lo a diversos elementos.\nUm aplicativo Shiny é um site, uma página na web. Ele terá um endereço (URL) que, quando acessado, exibirá informações em forma de texto e imagens1. Ser uma página web também significa que ele será constituído de HTML, CSS e JavaScript. Se você não conhece essas linguagens, uma boa maneira de entender o papel de cada uma delas no desenvolvimento de um site é pensar na construção de um prédio.\nPodemos pensar o HTML como a estrutura física do prédio: chão, paredes, colunas, teto, encanamento, fiação etc; o CSS é o responsável pela aparência: pintura, pisos, azulejos, decoração em geral; e o JavaScript traz elementos de funcionalidade ao prédio: portas, janelas, interruptores, elevadores etc.\nCom o Shiny, construiremos esse prédio utilizando funções de R.\nUm aplicativo Shiny também é uma aplicação web. Isso significa que, além de exibir informações, o nosso site/aplicativo também permitirá que a gente interaja com ele enviando dados que serão processados para criar novas informações. Essa interação gera um componente fundamental de um Shiny app: o servidor. Todo aplicativo Shiny será hospedado em um servidor com uma sessão de R rodando.\nPor fim, um aplicativo Shiny também é um código (ou uma coleção de códigos) em linguagem R. O pacote shiny, ao lado de muitos outros pacotes criados pela RStudio e pela comunidade, possui funções que (1) criam a estrutura e o visual do site/aplicativo, (2) montam a lógica de comunicação entre a pessoa que está utilizando o app e o servidor e (3) permite a construção da lógica interna do aplicativo, onde criamos as visualizações que serão exibidas na página a partir de código R puro. Esse último item significa que podemos utilizar todo arsenal de manipulação, visualização e modelagem do R em nossos aplicativos Shiny!\nAlém dessas definições, ainda há diversos pontos sobre implantação e hospedagem dos aplicativos para completar a discussão sobre o framework Shiny. Esses tópicos serão tratados mais a frente neste livro, no Capítulo 9.\nNa próxima seção, apresentaremos os componentes básicos de um aplicativo Shiny, tanto conceitualmente quanto no código.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Seu primeiro aplicativo Shiny</span>"
    ]
  },
  {
    "objectID": "primeiro-app.html#os-componentes-básicos",
    "href": "primeiro-app.html#os-componentes-básicos",
    "title": "1  Seu primeiro aplicativo Shiny",
    "section": "1.2 Os componentes básicos",
    "text": "1.2 Os componentes básicos\nUm aplicativo Shiny tem dois componentes básicos: a interface de usuário e o servidor.\nO primeiro componente se refere à(s) tela(s) do aplicativo, àquilo que veremos quando estivermos usando o app. Já o segundo componente se refere ao que não veremos: a lógica interna do app.\nDesenvolver a interface de usuário ou UI (sigla para o termo user interface, em inglês) significa construir o código HTML que compõe o app. Retomando a analogia do prédio, você precisa determinar explicitamente quais são e onde ficam as paredes do seu aplicativo. Isso é feito a partir de funções do pacote Shiny que geram HTML.\nA princípio, você não precisará se preocupar com CSS, pois a aparência padrão do Shiny2 é bem razoável. O mesmo vale para o JavaScript: quando você programa em Shiny, todo o JavaScript necessário para o seu app funcionar corretamente já está pronto e será utilizado automaticamente.\nA figura a seguir mostra a UI de um app bem simples, que permite a escolha de duas variáveis e apresenta o gráfico de dispersão delas:\n\n\n\n\n\nUI de um app simples.\n\n\n\n\nO lado do servidor (server side ou simplesmente server, em inglês) contém toda a lógica para a construção das visualizações apresentadas na UI. No exemplo da figura anterior, o código que gera o gráfico de dispersão fica dentro do servidor.\nEmbora precisemos aprender alguns conceitos e regras novas, a maior parte do código que compõe o servidor é aquele bom e velho R que já utilizamos no dia-a-dia para gerar tabelas, gráficos e qualquer outro tipo de visualização. Em resumo, para fazer um ggplot aparecer no Shiny, basta adaptar o código que gera esse gráfico para receber as informações que vêm da UI (inputs) e devolver o resultado (output) de maneira adequada.\nA UI e o servidor são os dois elementos básicos de um aplicativo Shiny. Embora sejam construídos separadamente, um depende do outro e a correta conexão desses componentes é o que gera a interatividade do app. Teremos sempre requisições sendo feitas pela UI, processadas pelo servidor e seus resultados devolvidos à UI. Esse processo está resumido no esquema a seguir:\n\n\n\n\n\nEsquema UI/servidor de um aplicativo Shiny.\n\n\n\n\nVocê pode acessar o app utilizado como exemplo nesta seção clicando aqui. Dado o esquema apresentado na figura anterior, tente imaginar o que está acontecendo sempre que você seleciona uma nova variável dentro do app. Como o novo gráfico é gerado? Qual é o papel do servidor? Como ele se comunica com a UI que você está vendo?\nNa próxima seção, vamos começar a responder essas perguntas mostrando como construímos a UI e o servidor de um Shiny app utilizando o pacote shiny.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Seu primeiro aplicativo Shiny</span>"
    ]
  },
  {
    "objectID": "primeiro-app.html#estrutura-de-um-código-shiny",
    "href": "primeiro-app.html#estrutura-de-um-código-shiny",
    "title": "1  Seu primeiro aplicativo Shiny",
    "section": "1.3 Estrutura de um código Shiny",
    "text": "1.3 Estrutura de um código Shiny\nNa seção anterior, falamos que a construção da UI corresponde à construção do código HTML que compõe o aplicativo. Fazemos isso utilizando funções do R que retornam HTML. Esse é um dos papéis do pacote shiny e um dos desafios da programação em Shiny. Não precisaremos aprender HTML formalmente, mas precisaremos aprender quais funções utilizar para construir uma UI bem estruturada.\nTambém falamos que o servidor é responsável por receber os códigos que geram as visualizações apresentadas na UI, conectando os inputs e outputs do aplicativo. No código, isso sempre será feito dentro de uma função chamada server.\nCom isso em mente, o código de qualquer aplicativo Shiny terá a estrutura abaixo:\n\num objeto chamado ui;\numa função chamada server;\ne uma chamada da função shinyApp().\n\nComo exemplo, observe o código a seguir. Ele representa um dos aplicativos mais simples que podemos construir:\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\"Olá, mundo!\")\n\nserver &lt;- function(input, output, session) {\n  \n}\n\nshinyApp(ui, server)\n\nEsse código resultará no aplicativo com a seguinte UI:\n\n\n\n\n\nUI do aplicativo “Olá, mundo!”.\n\n\n\n\nVejam que a UI se trata apenas de uma página de fundo branco com a frase “Olá, mundo!” escrita no canto superior esquerdo. O app não possui nenhuma interatividade.\nOlhando o código anterior, encontramos a frase “Olá, mundo!” na definição do objeto ui, dentro da função fluidPage(). Essa função do pacote shiny é uma entre várias que utilizaremos para retornar código HTML e precisamos utilizá-la para que o HTML do aplicativo funcione corretamente. Falaremos mais sobre ela no Capítulo 5.\n\nui &lt;- fluidPage(\"Olá, mundo!\")\n\nO importante por enquanto é sabermos que o objeto ui é responsável por receber todo o código HTML do nosso aplicativo.\nA função server sempre receberá os argumentos input, output e session. A partir desses argumentos, montaremos a lógica interna (ou reativa, guarde esse nome) do app. O código que gera as visualizações será escrito dentro dessa função. Como o nosso app Olá, mundo! não possui visualizações ou interatividade, a sua função server está vazia3.\n\nserver &lt;- function(input, output, session) {\n  # O código do server seria colocado aqui.\n}\n\nA última linha de código do nosso pequeno app contém a chamada shinyApp(ui, server). Essa função vai juntar o objeto ui e a função server, construir toda a arquitetura necessária e rodar o aplicativo. Não discutiremos aqui como tudo isso é feito pois envolve tópicos fora do escopo de um material introdutório. Por enquanto, é importante lembrar que essa função sempre deve ser chamada ao fim do código de um Shiny app.\nNa próxima seção, vamos discutir como rodar localmente um aplicativo Shiny e o que acontece no nosso computador quando estamos fazendo isso.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Seu primeiro aplicativo Shiny</span>"
    ]
  },
  {
    "objectID": "primeiro-app.html#rodando-um-aplicativo",
    "href": "primeiro-app.html#rodando-um-aplicativo",
    "title": "1  Seu primeiro aplicativo Shiny",
    "section": "1.4 Rodando um aplicativo",
    "text": "1.4 Rodando um aplicativo\nPara fazer o seu primeiro aplicativo em Shiny, abra o RStudio e copie o código do app Olá, mundo! (apresentado novamente a seguir) em um arquivo chamado app.R. Recomendamos fortemente que vocês utilizem projetos e que, neste primeiro momento, sempre salvem o script dos aplicativos na raiz do projeto.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\"Olá, mundo!\")\n\nserver &lt;- function(input, output, session) {\n  \n}\n\nshinyApp(ui, server)\n\nRepare que algumas opções novas aparecerão no RStudio quando salvamos o arquivo. Isso acontece porque o RStudio reconhece a sintaxe do código como a de um aplicativo Shiny, habilitando para nós algumas ferramentas que são úteis apenas para trabalhar com apps. A mais importante por enquanto será o botão Run App.\nComo discutimos anteriormente, um aplicativo Shiny em funcionamento sempre terá um computador rodando uma sessão de R por trás. Esse computador, chamado genericamente de servidor, pode ser uma máquina virtual em um serviço de nuvem, uma máquina virtual em um serviço de hospedagem, um servidor dentro da sua empresa, um servidor na sua casa ou mesmo o seu próprio computador pessoal.\nNormalmente, enquanto estamos desenvolvendo um aplicativo Shiny, queremos testá-lo localmente4 para verificar se tudo funciona corretamente, se está ficando bonito ou simplesmente para gastar alguns minutos apreciando a nossa obra de arte. Testar localmente significa que o seu próprio computador fará as vezes de servidor, embora isso não signifique que seu app ficará disponível na internet.\nQuando servimos um app localmente, isto é, quando rodamos um app, ganhamos um endereço que será acessível apenas do nosso computador. A partir desse endereço, podemos testar nosso app no navegador, como se ele já estivesse em produção. No RStudio, para rodar nossos apps, utilizamos justamente o botão Run App.\n\n\n\n\n\nBotão Run App no Rstudio.\n\n\n\n\nAo clicar nesse botão, o seu navegador padrão será aberto5 e você verá a UI do nosso modesto app com apenas a frase “Olá, mundo!”.\nSe você voltar ao RStudio, eventualmente vai notar algo muito importante: a sua sessão de R estará ocupada! Mas isso não deveria ser uma surpresa, pois já discutimos que todo Shiny app tem uma sessão de R rodando por trás.\nEssa sessão fornece a comunicação da UI (ou do nosso navegador) com o servidor e é responsável por atualizar as visualizações apresentadas na UI, sempre que alguém interagir com o app. Embora o nosso app Olá, mundo não possuir interatividade, a estrutura necessária para que a interatividade aconteça ainda assim é criada pelo Shiny.\nPara liberar a sessão, basta clicar no botão “stop”, na parte de cima do Console, ou pressionar a tecla Esc. Veja que, ao fazer isso, a tela do app ficará cinza, indicando que ele foi desconectado do servidor e não funcionará mais corretamente.\n\n\n\n\n\nVeja que o sinal de stop identifica que a sessão de R está ocupada.\n\n\n\n\nNo console, após rodarmos o app, também aparecerá uma mensagem identificando o endereço do nosso aplicativo. Nesse caso, será um IP (http://127.0.0.1)6 com alguma porta que esteja disponível escolhida aleatoriamente (:4028). Esse endereço aparecerá no nosso navegador e poderemos copiá-lo e colá-lo em qualquer outra aba ou navegador que quisermos rodar o app.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Seu primeiro aplicativo Shiny</span>"
    ]
  },
  {
    "objectID": "primeiro-app.html#exercícios",
    "href": "primeiro-app.html#exercícios",
    "title": "1  Seu primeiro aplicativo Shiny",
    "section": "1.5 Exercícios",
    "text": "1.5 Exercícios\n1 - O que é um aplicativo web?\n\n2 - Quais são os componentes básicos de um aplicativo Shiny?\n\n3 - Por que a sessão do R fica ocupada quando rodamos um app localmente?\n\n4 - Sobre o código de um aplicativo Shiny, escolha a alternativa falsa.\n\nAs funções do R utilizadas na construção da UI são funções que retornam código HMTL.\nNão precisamos criar a função server se o app não tiver interatividade.\nA função server pode ser escrita sem o parâmetro session.\nEmbora seja uma boa prática usar os nomes ui e server, podemos adotar qualquer nome para esses elementos.\n\n\n5 - Por que o app criado pelo código abaixo retorna erro quando o rodamos?\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  \n)\n\nserver &lt;- function() {\n  \n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Seu primeiro aplicativo Shiny</span>"
    ]
  },
  {
    "objectID": "primeiro-app.html#footnotes",
    "href": "primeiro-app.html#footnotes",
    "title": "1  Seu primeiro aplicativo Shiny",
    "section": "",
    "text": "Embora seja incomum, você também pode mostrar vídeos em um Shiny app.↩︎\nIsto é, o código CSS que o Shiny importa por padrão.↩︎\nA função server sempre precisa existir, mesmo neste caso, quando não há interatividade↩︎\nE loucamente também.↩︎\nSe o app foi aberto na aba Viewer ou em uma janela do próprio RStudio, clique na seta para baixo ao lado do botão Run App e selecione a opção Run External.↩︎\nEsse número de IP é padrão e significa “o seu computador”.↩︎",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Seu primeiro aplicativo Shiny</span>"
    ]
  },
  {
    "objectID": "add-interatividade.html",
    "href": "add-interatividade.html",
    "title": "2  Adicionando interatividade",
    "section": "",
    "text": "2.1 Adicionando outputs\nOutputs representam as saídas do nosso aplicativo, isto é, tudo que queremos que nosso código R retorne para a UI. Essas saídas podem ser tabelas, gráficos, mapas, texto, imagens ou qualquer outro elemento HTML.\nOs outputs são definidos na UI e criados no server. Cada tipo de output é definido por uma função do tipo *Output(). Veja as principais funções dessa família:\nEssas funções especificam onde os outputs serão colocados dentro da UI. Elas não especificam como eles serão criados. Para isso, utilizamos as funções do tipo render*(), responsáveis por definir o código R que gera cada output. Além disso, elas renderizam os resultados para HTML, possibilitando que essas visualizações sejam inseridas no código HTML que gera a UI. Na grande maioria dos casos, teremos o par visualizacaoOutput() e renderVisualizacao().\nVeja a seguir as principais funções render*() e como elas se comunicam com as funções *Output().\nO argumento outputId das funções *Output() é utilizado para identificarmos cada output dentro da função server. Todos os outputs criados ficarão dentro da lista output. Veja a seguir, o exemplo de um aplicativo que contém um histograma da variável mpg da base mtcars.\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  \"Histograma da variável mpg\",\n  plotOutput(outputId = \"histograma\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$histograma &lt;- renderPlot({\n    hist(mtcars$mpg)\n  })\n  \n}\n\nshinyApp(ui, server)\nNo código acima:\nRode o código anterior para ver o aplicativo resultante. Repare que, embora tenhamos uma visualização sendo construída no servidor, ainda não temos interatividade, isto é, não conseguimos mudar nada no conteúdo dessa visualização a partir da UI.\nImportante! Podemos apenas escrever na lista output. Se tentarmos ler um valor dessa lista, o Shiny retornará um erro.\noutput$histograma\n#&gt; Error in $.shinyoutput: Reading from shinyoutput object is not allowed.\nPara fechar o ciclo da interatividade, precisamos agora incluir inputs.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adicionando interatividade</span>"
    ]
  },
  {
    "objectID": "add-interatividade.html#adicionando-outputs",
    "href": "add-interatividade.html#adicionando-outputs",
    "title": "2  Adicionando interatividade",
    "section": "",
    "text": "a função plotOutput() especifica o lugar na UI onde será colocado o histograma (no caso, logo abaixo do texto \"Histograma da variável mpg\");\npara criar o histograma, atribuímos o resultado da função renderPlot() ao valor histograma da lista output, mesmo nome dado ao argumento outputId na função plotOutput();\na função renderPlot(), assim com qualquer outra função da família render*(), recebe como primeiro argumento o código para gerar o output;\no histograma é gerado com o código hist(mtcars$mpg).",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adicionando interatividade</span>"
    ]
  },
  {
    "objectID": "add-interatividade.html#adicionando-inputs",
    "href": "add-interatividade.html#adicionando-inputs",
    "title": "2  Adicionando interatividade",
    "section": "2.2 Adicionando inputs",
    "text": "2.2 Adicionando inputs\nInputs representam as entradas do nosso aplicativo, isto é, a maneira como informações são transmitidas entre a pessoa usando o app e o servidor. Essas informações podem ser valores, textos, datas, arquivos ou até mesmo cliques em um botão. Para facilitar a escolha desses valores1, o pacote shiny possibilita diversas opções de widgets2, a depender do tipo de valor a ser passado.\nVocê pode conferir a lista de widgets do pacote shiny nesta página. Repare que no campo Current Value(s) é mostrado qual valor será levado para dentro da função server em cada caso.\nPara criar esses widgets utilizamos as famílias de funções *Input() ou *Button. De forma análoga ao outputId das funções *Output(), todas essas funções possuem inputId como primeiro argumento, que recebe uma string e será utilizado para acessar dentro da função server cada um dos inputs criados. Isso implica que dois inputs não podem ter o mesmo inputId.\nNo código a seguir, incluímos no app da seção anterior uma caixa de seleção que permite a escolha da variável que será utilizada no histograma. Rode esse app e veja que o gráfico é recalculado sempre que alteramos a variável na caixa de seleção.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  \"Histograma da variável mpg\",\n  selectInput(\n    inputId = \"variavel\",\n    label = \"Selecione uma variável\",\n    choices = names(mtcars)\n  ),\n  plotOutput(outputId = \"histograma\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$histograma &lt;- renderPlot({\n    hist(mtcars[[input$variavel]])\n  })\n  \n}\n\nshinyApp(ui, server)\n\nA caixa de seleção foi criada pela função selectInput(). Essa função requer 3 argumentos:\n\no inputId, como discutido anteriormente;\no label, que será mostrado na tela e indica a quem estiver usando o app o que está sendo escolhido nesse input3;\ne o choices, um vetor com as possíveis escolhas da caixa de seleção.\n\nPara acessar o valor do input na função server, utilizamos a lista input e o nome dado no argumento inputId da função selectInput() (no caso, \"variavel\"). A lista input guarda todos os inputs criados na UI e, ao contrário da lista output, ela é somente leitura. Se você tentar escrever diretamente na lista input, o Shiny retornará um erro.\n\ninput$variavel &lt;- 10\n#&gt; Error in : Can't modify read-only reactive value 'variavel\n\nO widget selectInput() envia ao servidor uma string com o valor escolhido na caixa de seleção. Por isso utilizamos o operador [[ para fazer a seleção da variável. Quando o app é iniciado, por exemplo, input$variavel recebe o valor \"mpg\" e, por consequência, mtcars[[input$variavel]] será igual a mtcars[[\"mpg\"]], que retorna um vetor com os valores da coluna mpg e será utilizado pela função hist() para gerar o gráfico.\n\nmtcars[[\"mpg\"]]\n\n [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4\n[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7\n[31] 15.0 21.4\n\nhist(mtcars[[\"mpg\"]])\n\n\n\n\n\n\n\n\nO código a seguir gera um app com dois inputs e dois outputs. Rode o app e veja que cada input está associado a apenas um output.\n\nlibrary(shiny)\n\nvariaveis &lt;- names(mtcars)\n\nui &lt;- fluidPage(\n  selectInput(\n    inputId = \"variavel_A\",\n    label = \"Variável A\",\n    choices = variaveis\n  ),\n  plotOutput(outputId = \"histograma_A\"),\n  selectInput(\n    inputId = \"variavel_B\",\n    label = \"Variável B\",\n    choices = variaveis,\n    selected = variaveis[2],\n  ),\n  plotOutput(outputId = \"histograma_B\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$histograma_A &lt;- renderPlot({\n    print(\"Gerando histograma A...\")\n    hist(mtcars[[input$variavel_A]], main = \"Histograma A\")\n  })\n  \n  output$histograma_B &lt;- renderPlot({\n    print(\"Gerando histograma B...\")\n    hist(mtcars[[input$variavel_B]], main = \"Histograma B\")\n  })\n  \n}\n\nshinyApp(ui, server)\n\nRepare pelas mensagens no Console4 que, quando alteramos o valor da variável A, apenas o histograma A é recalculado. O mesmo vale para variável B e o histograma B. Isso acontece porque a relação entre inputs e outputs é mapeada quando rodamos o app e, quando modificamos um input, o Shiny roda novamente apenas o código necessário para recalcular os outputs associados a ele. Para entender como isso é feito e como podemos tirar proveito disso, precisamos entender o conceito de reatividade. Esse será o tópico do próximo capítulo.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adicionando interatividade</span>"
    ]
  },
  {
    "objectID": "add-interatividade.html#exercícios",
    "href": "add-interatividade.html#exercícios",
    "title": "2  Adicionando interatividade",
    "section": "2.3 Exercícios",
    "text": "2.3 Exercícios\n1 - No contexto do Shiny, o que são inputs? E outputs?\n\n2 - Como fazemos para acessar os valores dos inptus dentro da função server?\n\n3 - Qual a função da família de funções *Output()? Onde essas funções são utilizadas?\n\n4 - Qual a função da família de funções render*()? Onde essas funções são utilizadas?\n\n5 - Faça um shiny app para visualizar histogramas da base ggplot2::diamonds e o coloque no shinyapps.io.\nSeu shiny deve ter um input e um output.\n\nInput: variáveis numéricas da base diamonds.\nOutput: histograma da variável selecionada.\n\nPara acessar a base diamonds, carregue o pacote ggplot2\n\nlibrary(ggplto2)\ndiamonds\n\n# ou rode\n\nggplot2::diamonds\n\n\n6 - Reproduza este Shiny app.\nPara acessar a base utilizada, rode o código abaixo:\n\n# Pacote com versão original da base (em inglês)\ninstall.packages(\"nycflights13\")\nnycflights13::flights\n\n# Pacote com versão em português da base\ninstall.packages(\"dados\")\ndados::voos",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adicionando interatividade</span>"
    ]
  },
  {
    "objectID": "add-interatividade.html#footnotes",
    "href": "add-interatividade.html#footnotes",
    "title": "2  Adicionando interatividade",
    "section": "",
    "text": "Isto é, melhorar a experiência de uso do aplicativo (UX, sigla para o termo em inglês user experience).↩︎\nTermo em inglês utilizado para se referir a elementos de interação, como caixas de seleção, botões, menus, ícones etc. Como esse termo dentro da literatura do Shiny é muito comum, vamos utilizá-lo neste livro para não criar grandes diferenças com as nomenclaturas de outras referências.↩︎\nA maioria das funções *Input() possui esse argumento.↩︎\nEssas mensagens são geradas pelas funções print() presentes dentro de cada renderPlot(). Essas mensagens não aparecem no app, apenas no Console, e são uma boa alternativa para testar e procurar erros no código.↩︎",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Adicionando interatividade</span>"
    ]
  },
  {
    "objectID": "reatividade-conceitos.html",
    "href": "reatividade-conceitos.html",
    "title": "3  Reatividade: conceitos básicos",
    "section": "",
    "text": "3.1 O que é reatividade?\nQuando escrevemos código R, dois paradigmas estão sempre presentes:\nIsso faz nossas tarefas de análise de dados virarem scripts sequenciais, cujo código não pode ser executado fora de ordem.\nO código abaixo, que executa a corriqueira tarefa de importar, manipular e visualizar uma base, mostra um exemplo disso. Construímos o código rodando linha a linha, para testar se estamos seguindo pelo caminho certo. Ao final, podemos rodar tudo de uma vez para obter o resultado desejado (o gráfico). Se o código for rodado fora de ordem, nada vai funcionar. Essa maneira de escrever e avaliar códigos é conhecida como programação imperativa.\ntab_starwars &lt;- dplyr::starwars\n\ntab_grafico &lt;- tab_starwars |&gt;\n  tidyr::unnest(films) |&gt; \n  tidyr::drop_na(species) |&gt; \n  dplyr::group_by(films) |&gt;\n  dplyr::summarise(total_especies = dplyr::n_distinct(species)) |&gt; \n  dplyr::mutate(\n    films = forcats::fct_reorder(films, total_especies)\n  )\n\ntab_grafico |&gt; \n  ggplot2::ggplot(ggplot2::aes(y = films, x = total_especies)) +\n  ggplot2::geom_col() +\n  ggplot2::theme_minimal() +\n  ggplot2::labs(x = \"Total de espécies\", y = \"Filme\")\nA reatividade reside em um outro paradigma de programação, conhecido como programação declarativa. Nela, não construímos códigos que serão rodados interativamente ou sequencialmente, mas sim uma receita que especifica o que o computador deve fazer a depender da situação apresentada. Mais especificamente, a receita ensina ao computador qual código deve ser executado e quando.\nNo contexto do Shiny, essa receita é um conjunto de dependências que será utilizado para decidir quais outputs devem ser recalculados quando um input muda. Não somos nós que rodamos o código que gera um output, nós apenas definimos qual código será esse. O ambiente criado pelo Shiny a partir da nossa receita (quando um app está em funcionamento) é quem decide a hora certa de executar esse código (se é que ele será executado).\nTodo esse processo, que envolve monitorar mudanças nos inputs para atualizar os outputs a partir de uma receita composta de códigos executados apenas quando necessário, é o que chamamos de reatividade. A melhor parte é que o Shiny cuida sozinho de quase tudo, cabendo a nós apenas especificar a receita de maneira adequada.\nNa prática, essa receita nada mais é do que a função server(). São os códigos que escrevemos na função server() que determinam as dependências entre inputs e outputs. Chamaremos aqui o conjunto de dependências de um app de diagrama de reatividade.\nPara ilustrar esses conceitos, considere o app gerado pelo código a seguir.\nlibrary(shiny)\n\nvariaveis &lt;- names(mtcars)\n\nui &lt;- fluidPage(\n  selectInput(\n    inputId = \"variavel_A\",\n    label = \"Variável A\",\n    choices = variaveis\n  ),\n  plotOutput(outputId = \"histograma_A\"),\n  selectInput(\n    inputId = \"variavel_B\",\n    label = \"Variável B\",\n    choices = variaveis,\n    selected = variaveis[2],\n  ),\n  plotOutput(outputId = \"histograma_B\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$histograma_A &lt;- renderPlot({\n    print(\"Gerando histograma A...\")\n    hist(mtcars[[input$variavel_A]], main = \"Histograma A\")\n  })\n  \n  output$histograma_B &lt;- renderPlot({\n    print(\"Gerando histograma B...\")\n    hist(mtcars[[input$variavel_B]], main = \"Histograma B\")\n  })\n  \n}\n\nshinyApp(ui, server)\nImagem de um Shiny app com dois inputs e dois outputs.\nO diagrama de reatividade desse app, determinado pela função server(), pode ser representado pelo seguinte esquema:\nDiagrama de reatividade de um app com dois inputs e dois outputs.\nO diagrama mostra que a reatividade desse aplicativo possui dois caminhos independentes, um começando com o input variavel_A e terminando no output histograma_A e o outro começando com o variavel_B e terminando no output histograma_B. A ausência de conexão entre o histograma_A e a variavel_B indica que, ao mudarmos a variavel_B, o histograma_A não será recalculado. A mesma ausência de conexão existe entre o histograma_B e a variavel_A.\nA ligação direta de um único input com um único output é o esquema reativo mais simples que um app pode apresentar. Na prática, vamos precisar construir interações mais complexas entre inputs e outputs, o que ainda não é possível com as peças que temos disponíveis. Para isso, precisaremos de funções que manipulem o caminho da reatividade.\nNo restante deste capítulo, aprenderemos alguns conceitos e funções que nos permitirão ter um controle maior sobre a reatividade no Shiny. Não esgotaremos o assunto reatividade aqui, ele será retomado no Capítulo 7 e no Capítulo 14, mas já sairemos capazes de construir diversos tipos de interação entre inputs e outputs em nossos apps.\nComeçaremos aprendendo as estruturas básicas do diagrama de reatividade: valores reativos, observers e expressões reativas.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Reatividade: conceitos básicos</span>"
    ]
  },
  {
    "objectID": "reatividade-conceitos.html#o-que-é-reatividade",
    "href": "reatividade-conceitos.html#o-que-é-reatividade",
    "title": "3  Reatividade: conceitos básicos",
    "section": "",
    "text": "podemos avaliar uma linha de código assim que a escrevermos; e\nse decidirmos rodar todo o script de uma vez, as linhas de código serão avaliadas sequencialmente.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Reatividade: conceitos básicos</span>"
    ]
  },
  {
    "objectID": "reatividade-conceitos.html#valores-reativos-e-funções-observadoras",
    "href": "reatividade-conceitos.html#valores-reativos-e-funções-observadoras",
    "title": "3  Reatividade: conceitos básicos",
    "section": "3.2 Valores reativos e funções observadoras",
    "text": "3.2 Valores reativos e funções observadoras\nPara programar em Shiny, precisamos aprender um conjunto de conceitos e ferramentas. Até aqui, fizemos isso definindo como o Shiny funciona e explicando como utilizar o pacote shiny para criar nossos apps. Agora, além de explorar novas funções, adicionaremos à nossa lista de conceitos algumas regras importantes para que nossos apps funcionem corretamente.\nVimos na seção anterior que um aplicativo Shiny depende da especificação adequada do diagrama de reatividade. Isso quer dizer que devemos seguir alguns princípios na construção da função server para que o Shiny consiga montar esse diagrama e para que a reatividade aconteça.\nO primeiro desses princípios é o seguinte: todo diagrama de reatividade deve começar com um valor reativo e terminar com uma função observadora. Nós já utilizamos valores reativos e funções observadoras antes. Vamos definir o que são estruturas.\nValores reativos são objetos que disparam a reatividade do app a partir de mudanças nos seus valores. Os objetos da input são o exemplo mais comum de valores reativos. Funções observadoras são funções que “observam” mudanças nos valores reativos e, quando elas acontecem, recalculam o seu código. As funções da famílias render*() são os exemplos mais comuns de funções observadoras.\nVoltando app dado como exemplo na seção anterior, quando a “Variável A” é alterada na UI, o seguinte processo acontece:\n\no valor reativo input$variavel_A emite um sinal de alerta a todas as funções observadoras que dependem dele dizendo que seu valor mudou;\na função observadora renderPlot(), que depende de input$variavel_A, ao saber que esse valor reativo está desatualizado, desatualiza o seu próprio resultado, isto é, o output histograma_A;\na função renderPlot() consulta o novo valor de input$variavel_A e o utiliza para recalcular seu resultado (o código dentro da renderPlot() é rodado novamente);\no novo histograma é gerado e enviado para a UI, encerrando o processo reativo.\n\nEsse processo, que podemos chamar de fluxo reativo, só é disparado por mudanças em valores reativos e só acontece quando o ponto final é uma função observadora.\nOs valores da lista input não são o único tipo de valores reativos, assim como as funções render*() não são o único tipo de funções observadoras. Falaremos mais de outros valores reativos e observers no Capítulo 7.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Reatividade: conceitos básicos</span>"
    ]
  },
  {
    "objectID": "reatividade-conceitos.html#expressões-reativas",
    "href": "reatividade-conceitos.html#expressões-reativas",
    "title": "3  Reatividade: conceitos básicos",
    "section": "3.3 Expressões reativas",
    "text": "3.3 Expressões reativas\nMuitas vezes, precisamos criar objetos dentro do Shiny que dependem de valores reativos e que serão utilizados dentro de uma ou mais funções observadoras. Tal objeto precisaria se comportar tanto como uma função observadora, pois observaria o valor reativo do qual depende, quanto como uma valor reativo, para disparar a reatividade dentro das funções observadoras onde ele será usado.\nEsses objetos existem e são chamados de expressões reativas, a peça faltante no problema apresentado na introdução deste capítulo. Para criar expressões reativas, utilizamos as funções reactive() e eventReactive().\n\n3.3.1 A função reactive()\nA função reactive() cria uma expressão reativa que observa todos os valores reativos presentes dentro de seu código. No exemplo a seguir, a expressão reativa amostra recalcula o seu valor sempre que o valor reativo input$tamanho mudar.\n\n# server\namostra &lt;- reactive({\n  sample(1:10, input$tamanho, replace = TRUE)\n})\n\nJá neste próximo exemplo, a expressão reativa soma recalcula o seu valor sempre que qualquer um dos valores reativos input$valor1, input$valor2 e input$valor3 mudar.\n\nsoma &lt;- reactive({\n  input$valor1 + input$valor2 + input$valor3\n})\n\nPara acessar o valor de uma expressão reativa, devemos usar parênteses após o seu nome, como se estivéssemos chamando uma função sem argumentos. Podemos utilizar esse valor dentro de qualquer outra expressão reativa ou função observadora, quantas vezes for preciso.\nNo código a seguir, criamos a expressão reativa amostra e utilizamos o seu valor chamando amostra() dentro das funções observadoras renderPlot() e renderText(). Essa é a solução para o problema apresentado no início do capítulo.\n\n# server\namostra &lt;- reactive({\n  sample(1:10, input$tamanho, replace = TRUE)\n})\n\noutput$grafico &lt;- renderPlot({\n  amostra() |&gt; \n    table() |&gt; \n    barplot()\n})\n\noutput$resultado &lt;- renderText({\n  contagem &lt;- table(amostra())\n  mais_freq &lt;- names(contagem[which.max(contagem)])\n  glue::glue(\"O valor mais sorteado foi o {mais_freq}.\")\n})\n\nNesse exemplo, se o valor de input$tamanho mudar o seguinte processo acontecerá internamente no Shiny:\n\no valor reativo input$tamanho vai emitir um alerta avisando que seu valor está desatualizado;\na expressão reativa amostra receberá esse alerta, desatualizará o próprio valor (a amostra sorteada) e também emitirá um alerta;\ntanto a função observadora renderPlot() quanto a renderText() receberão o alerta da expressão reativa amostra e invalidarão os seus resultados (o gráfico e o texto);\nas funções observadoras consultarão o valor atualizado da expressão reativa amostra que, por sua vez, consultará o valor atualizado do valor reativo input$tamanho;\ncom o valor atualizado do input$tamanho, a expressão reativa amostra recalcula o seu valor (uma nova amostra é gerada) e, em seguida, as funções observadoras renderPlot() e renderText() recalculam seus resultados (o gráfico e o texto são gerados novamente).\n\nO diagrama reativo nesse caso pode ser representado pelo esquema a seguir:\n\n\n\n\n\nDiagrama de reatividade de um app com um valor reativo, uma expressão reativa e duas funções observadoras.\n\n\n\n\n\n\n3.3.2 A função eventReactive()\nEnquanto a função reactive() observa mudanças em todos os valores reativos presentes no código dela, a função eventReactive() observa mudanças em apenas um valor reativo, especificado na chamada da própria função. No código a seguir, a soma só recalculada quando o valor input$valor1 mudar. Alterar os valores de input$valor2 ou input$valor3 não vai fazer a expressão reativa soma disparar reatividade.\n\nsoma &lt;- eventReactive(input$valor1, {\n  input$valor1 + input$valor2 + input$valor3\n})\n\nA eventReactive() é muito utilizada com botões, criados na UI com a função actionButton(). No app apresentado a seguir, a amostra só é gerada quando a pessoa usando o app clicar no botão “Gerar gráfico”. Rode o app e teste esse comportamento.\n\n# ui\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  \"Resultado do sorteio\",\n  sliderInput(\n    inputId = \"tamanho\",\n    label = \"Selecione o tamanho da amostra\",\n    min = 1,\n    max = 1000,\n    value = 100\n  ),\n  actionButton(\"botao\", \"Gerar gráfico\"),\n  plotOutput(outputId = \"grafico\"),\n  textOutput(outputId = \"resultado\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  amostra &lt;- eventReactive(input$botao, {\n    sample(1:10, input$tamanho, replace = TRUE)\n  })\n  \n  output$grafico &lt;- renderPlot({\n    amostra() |&gt; \n      table() |&gt; \n      barplot()\n  })\n  \n  output$resultado &lt;- renderText({\n    contagem &lt;- table(amostra())\n    mais_freq &lt;- names(contagem[which.max(contagem)])\n    glue::glue(\"O valor mais sorteado foi o {mais_freq}.\")\n  })\n}\n\nshinyApp(ui, server)\n\nVeja que o valor reativo input$botao, especificado no primeiro argumento da função eventReactive(), funciona como o gatilho do fluxo de reatividade. Isso significa que a expressão reativa amostra será recalculada apenas quando apertarmos o botão Gerar gráfico. Mudanças no slider não resultarão em qualquer mudança no app (estamos impedindo que input$tamanho inicie o fluxo de reatividade). Repare também que o código que gera a amostra é passado no segundo argumento da função eventReactive().\nO diagrama reativo desse app pode ser representado pelo esquema a seguir. A linha pontilhada indica que o input$tamanho não dispara reatividade.\n\n\n\n\n\nDiagrama de um fluxo de reatividade iniciado por um botão. A linha pontilhada indica que o input$tamanho não dispara reatividade.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Reatividade: conceitos básicos</span>"
    ]
  },
  {
    "objectID": "reatividade-conceitos.html#contexto-reativo",
    "href": "reatividade-conceitos.html#contexto-reativo",
    "title": "3  Reatividade: conceitos básicos",
    "section": "3.4 Contexto reativo",
    "text": "3.4 Contexto reativo\nVimos na introdução do capítulo que a nossa segunda tentativa — colocar a criação da amostra diretamente na função server — retorna um erro. Isso acontece porque valores e expressões reativas só podem ser lidas dentro de um contexto reativo. Essa é outra regra do Shiny, e precisamos segui-la para que ele consiga montar o diagrama de reatividade.\nContexto reativo remete a qualquer função que observe mudanças em valores reativos, como expressões reativas ou funções observadoras. Basicamente, o processo do Shiny que interpreta a função server e cria o diagrama de reatividade não sabe o que fazer quando valores e expressões reativas estão fora de contexto reativo. Então recebemos um erro.\nNo exemplo abaixo, a função renderPlot() cria um contexto reativo e, por isso, podemos utilizar o valor reativo input$variavel dentro dela.\n\nserver &lt;- function(input, output, session) {\n  output$hist &lt;- renderPlot({\n    hist(input$variavel)\n  }) \n}\n\nSempre que tentamos usar um valor ou expressão reativa fora de um contexto reativo, o Shiny retornará o erro a seguir.\n\nserver &lt;- function(input, output, session) {\n  output$hist &lt;- hist(input$variavel)\n}\n#&gt; Error : Can't access reactive value 'variavel' outside of\n# reactive consumer.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Reatividade: conceitos básicos</span>"
    ]
  },
  {
    "objectID": "reatividade-conceitos.html#visualizando-o-diagrama-de-reatividade-reactlog",
    "href": "reatividade-conceitos.html#visualizando-o-diagrama-de-reatividade-reactlog",
    "title": "3  Reatividade: conceitos básicos",
    "section": "3.5 Visualizando o diagrama de reatividade: reactlog",
    "text": "3.5 Visualizando o diagrama de reatividade: reactlog\nA construção adequada do diagrama de dependências reativas costuma ser o maior desafio no desenvolvimento de aplicativos Shiny. Quanto mais engrenagens precisam girar juntas dentro de um app, mais complicada pode ser a lógica de programação para que a reatividade funcione de maneira correta.\nSe, ao mudar o valor de um slider, esperamos que um gráfico seja atualizado, dois problemas podem surgir: (1) o gráfico não ser recalculado e (2) o gráfico ser recalculado mais de uma vez.\nOs dois problemas indicam um diagrama de reatividade mal construído. A diferença é que, enquanto no primeiro caso o app não funciona, no segundo, ignorando-se o comportamento estranho, ele entrega o que se espera dele.\n\nUm app que aparentemente funciona do jeito que gostaríamos pode esconder problemas de reatividade que o deixam mais lento ou com comportamentos estranhos, atrapalhando a experiência na hora do uso.\n\nPara evitar esses problemas, que discutiremos com mais detalhes no Capítulo 7 e no Capítulo 14, podemos imaginar ou desenhar o diagrama de reatividade para investigar onde está a falha. Essa é uma tarefa simples em apps com poucos inputs e outputs, mas extremamente difícil ou inviável em apps complexos.\nNesses casos (ou mesmo nos casos simples), podemos utilizar o pacote reactlog. Com ele, conseguimos visualizar facilmente o diagrama de dependências reativas de qualquer Shiny app e olhar o que acontece por trás das cortinas da reatividade quando executamos o aplicativo.\nAntes de mais nada, instale o pacote reactlog.\n\ninstall.packages(\"reactlog\")\n\nEm seguida, no Console, rode o código abaixo. Isso vai habilitar o reactlog para qualquer app que você rodar na atual sessão de R.\n\noptions(shiny.reactlog = TRUE) \n\nPor fim, rode o seu app e utilize o comando CTRL + F3 (no Mac, command + F3). O seu navegador abrirá uma nova aba com o diagrama de reatividade.\nNo exemplo a seguir, temos a UI de um aplicativo que gera o histograma de uma amostra com distribuição normal. O tamanho da amostra é determinado pelo sliderInput. Sempre que o tamanho da amostra muda, o gráfico é recalculado.\n\n\n\n\n\nShiny app que mostra o histograma de uma amostra com distribuição normal. O tamanho da amostra é determinado por um sliderInput.\n\n\n\n\nVeja agora o diagrama de reatividade associado a esse app. A forma dos 4 elementos mais a esquerda representa valores reativos, a forma do elemento plotObj representa expressões reativas e a forma do elemento output$hist representa funções observadoras.\n\n\n\n\n\nDiagrama de reatividade do app anterior.\n\n\n\n\nParece muito mais complicado do que deveria, né? Acontece que além do input e output, o diagrama também apresenta elementos referentes ao tamanho da janela do navegador que está acessando o app. Esses elementos influenciam na imagem produzida para o gráfico dentro do HTML, que é redimensionada a depender do tamanho da tela. Por isso a existência do elemento intermediário plotObj, que guarda as instruções para gerar o gráfico criadas pelo código R. Assim, o código R no servidor não precisa ser rodado novamente para que a imagem do gráfico seja redimensionada.\nPodemos filtrar o diagrama para mostrar apenas o fluxo relacionado aos inputs do aplicativo escrevendo input no campo de busca no canto superior direito. Repare também que os controles no canto superior esquerdo permitem visualizar o fluxo de reatividade das ações realizadas entre a inicialização do app e o momento em que criamos o diagrama (quando pressionamos CTRL + F3).\n\n\n\n\n\nCampo de busca e controles de visualização do fluxo de reatividade.\n\n\n\n\nEm resumo, com um diagrama de reatividade em mãos, podemos:\n\nver os inputs dos quais cada output depende e não depende;\ninvestigar por que o código de um output não é rodado ou roda duas vezes quando acionamos um input do qual ele deveria depender;\nter uma visão menos abstrata do fluxo de reatividade e entender melhor o que acontece quando executamos cada parte do nosso app.\n\nUtilize o código a seguir para reproduzir o app mostrado nesta seção. Mexa algumas vezes no slider e gere o diagrama de reatividade. Use os controles de navegação para visualizar cada etapa do ciclo reativo.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  \"Histograma da distribuição normal\",\n  sliderInput(\n    inputId = \"num\",\n    label = \"Selecione o tamanho da amostra\",\n    min = 1,\n    max = 1000,\n    value = 100\n  ),\n  plotOutput(outputId = \"hist\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$hist &lt;- renderPlot({\n    amostra &lt;- rnorm(input$num)\n    hist(amostra)\n  })\n  \n}\n\nshinyApp(ui, server)\n\nComo descrito na documentação da ferramenta, por razões de segurança e performance, nunca habilite o reactlog em ambientes de produção. Quando ele está habilitado, qualquer pessoal utilizando o seu app pode ver pelo menos parte do seu código fonte (que eventualmente pode conter informações sensíveis).\nVocê pode aprender mais sobre o funcionamento do reactlog clicando aqui.\nNa sequência deste livro, sugerimos utilizar o reactlog sempre que ficar com dúvida sobre o diagrama de reatividade de um app.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Reatividade: conceitos básicos</span>"
    ]
  },
  {
    "objectID": "reatividade-conceitos.html#exercícios",
    "href": "reatividade-conceitos.html#exercícios",
    "title": "3  Reatividade: conceitos básicos",
    "section": "3.6 Exercícios",
    "text": "3.6 Exercícios\n1 - Qual a diferença entre programação imperativa e programação declarativa?\n\n2 - O que é reatividade?\n\n3 - Qual o papel da função server no contexto da reatividade de um aplicativo Shiny?\n\n4 - O que são valores reativos? E funções observadoras?\n\n5 - Para que servem as expressões reativas?\n\n6 - Qual a diferença entre as funções reactive() e eventReactive()?\n\n7 - Selecione a opção verdadeira.\n\nSempre que mudarmos o valor de um input na UI de um app, todo o código na função server será rodado novamente.\nExpressões reativas são o ponto de partida do diagrama de reatividade.\nPodemos criar valores reativos com a função reactive().\nAs funções da família render* são um exemplo de função observadora.\n\n\n8 - Faça um shiny app para visualizarmos boxplots da base ggplot2::diamonds.\nO seu app deve ter dois inputs e um output:\n\no primeiro input deve ser uma caixa de seleção das variáveis numéricas da base (será o eixo y do gráfico).\no segundo input deve ser uma caixa de seleção das variáveis categóricas da base (será o eixo x do gráfico).\no output deve ser um gráfico com os boxplots da variável escolhida em (1) para cada categoria da variável escolhida em (2).\n\nPara acessar a base diamonds, carregue o pacote ggplot2:\n\nlibrary(ggplto2)\ndiamonds\n\n# ou rode\n\nggplot2::diamonds\n\n\n9 - Selecionando várias opções em um selectInput.\n\nReproduza o seguinte Shiny app: https://cursodashboards.shinyapps.io/select-multiple/\nTroque o selectInput pelo checkboxGroupInput().\n\nPara acessar a base utilizada, rode o código abaixo:\n\ninstall.packages(\"nycflights13\")\nnycflights13::flights\n\n# Pacote com versão em português da base\ninstall.packages(\"dados\")\ndados::voos\n\n\n10 - Faça um Shiny app para explorar a base de filmes da Pixar.\n\n# Instale o pacote com a versão original da base (em inglês)\ninstall.packages(\"pixarfilms\")\n\n# Instale pacote com versão em português da base\ninstall.packages(\"dados\")\n\nSugestões:\n\nInput: data de lançamento (dateRangeInput). Output: tabela de filmes.\nInput: filme. Outputs: orçamento, bilheteria, gênero, prêmios e notas.\nInput: caixa de texto para escrever um nome. Outputs: tabela com filmes que essa pessoa participou e qual papel ela exerceu no filme (direção, roteiro, produção etc)\n\nDica: você precisará fazer join das bases do pacote para juntar as informações.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Reatividade: conceitos básicos</span>"
    ]
  },
  {
    "objectID": "reatividade-conceitos.html#footnotes",
    "href": "reatividade-conceitos.html#footnotes",
    "title": "3  Reatividade: conceitos básicos",
    "section": "",
    "text": "Claro que poderíamos usar a função set.seed() para garantir que as amostras fossem as mesmas, mas imagine que não queremos escolher uma semente para a geração dos dados ou que, em algum outro contexto, o processo de amostragem fosse demorado e não queremos fazê-lo duas vezes.↩︎",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Reatividade: conceitos básicos</span>"
    ]
  },
  {
    "objectID": "debug.html",
    "href": "debug.html",
    "title": "4  Debug",
    "section": "",
    "text": "4.1 Erros comuns\nA seguir, listamos erros frequentes no desenvolvimento de apps em Shiny. Alguns acontecem mais quando estamos começando a programar nesse framework, outros nos seguem ao longo de toda a jornada.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Debug</span>"
    ]
  },
  {
    "objectID": "debug.html#erros-comuns",
    "href": "debug.html#erros-comuns",
    "title": "4  Debug",
    "section": "",
    "text": "Erros comuns de programação em R\nErros comuns de programação em R, como chamar objetos ou funções inexistentes, operações não permitidas ou utilização inadequada de funções costumam devolver mensagens de erro informativas no Console. O primeiro passo para resolver esses problemas é ler a mensagem de erro. Caso a mensagem não te dê informação o suficiente para corrigir o erro, sempre vale a pena jogar a mensagem no Google e buscar pela resposta em fóruns de dúvidas.\n\n\nErros de sintaxe na UI ou no servidor\nEm geral, o app não roda e receberemos a mensagem de erro unexpected symbol. Esses erros são causados principalmente por falta ou excesso de vírgulas, parênteses ou chaves.\n\n\nErros de reatividade\nEsses erros violam premissas do Shiny, impedindo o Shiny de construir o diagrama de reatividade.\nA principal causa é utilizar um valor reativo ou avaliar uma expressão reativa fora de um consumidor reativo, isto é, uma função que observa valores reativos. O app não vai rodar e você verá a seguinte mensagem de erro:\n\n#&gt; Can't access reactive value 'inputId' outside of\n#&gt; reactive consumer..\n\nOutro erro de reatividade muito comum é esquecer os parênteses ao chamar uma expressão reativa (objeto criado pelas funções reactive() e eventReactive()). Normalmente receberemos uma mensagem indicando que a classe de algum objeto está errada, como 'x' must be numeric ou a famosa mensagem cannot coerce type 'closure' to vector of type ....\nOutras causas dizem respeito a utilização das listas input e output.\nVocê só pode ler valores da lista input. Se você tentar gravar um valor diretamente, será retornado um erro. Isso acontece porque a lista input deve sempre uma cópia das ações do usuário no navegador, uma premissa para que o diagrama de reatividade funcione de forma correta para atualizar os valores na tela.\nVocê só pode escrever valores na lista output. Se você tentar ler um valor, será retornado um erro. A lista output não contém os valores devolvidos para as funções render*() , mas sim o conteúdo transformado por essas funções para ser inserido no HTML.\n\n\nViolação de outras premissas do Shiny\nUm erro comum é não fazer a correspondência certa entre as funções _Output() e render_(). O app vai rodar, mas a visualização não será mostrada. Em algumas situações, uma mensagem de erro vai ser retornada. Em outras, o erro será silencioso.\nTambém não é raro errarmos o nome de um input (usar um input que não existe). O app vai rodar e, geralmente, retornar um erro relacionado a uma função receber um valor que não deveria ser NULL (já que o objeto input é uma lista e acessar um elemento que não existe em uma lista retorna o valor NULL).\nSe errarmos o nome de um output, o app vai rodar e não vai retornar erro. O output não será gerado. Nesse caso, estamos apenas criando uma visualização que não aparece em nenhum lugar no app.\nJá quando usamos o mesmo ID para dois outputs, o app vai rodar e não vai retornar erro. Os dois outputs não serão gerados.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Debug</span>"
    ]
  },
  {
    "objectID": "debug.html#encontrando-erros",
    "href": "debug.html#encontrando-erros",
    "title": "4  Debug",
    "section": "4.2 Encontrando erros",
    "text": "4.2 Encontrando erros\nA seguir, discutiremos dois métodos para encontrarmos a causa de erros em aplicativos Shiny: as funções cat() e browser().\n\n4.2.1 A função cat()\nUma maneira simples e eficiente de olhar o que está acontecendo dentro do server enquanto o app está rodando é imprimir no Console mensagens ou valores que nos dê pistas sobre a validade do nosso código.\nNo Shiny, a melhor maneira de fazer isso é utilizando a função cat(file = stderr(), \"mensagem\"). Utilizamos essa função em detrimento das funções print(\"mensagem\") ou simplesmente cat(\"mensagem\") pois essas duas não vão funcionar em alguns contextos2. O argumento file = stderr() garante que a mensagem será mostrada na conexão padrão para mensagens de erro (no Console, em geral).\nEsse método é muito útil para saber se ou quantas vezes o Shiny está passando por uma determinada parte do código ou para retornar e validar valores calculados dentro do servidor.\nExemplos:\n\n# Verificando quando o Shiny passa pelo reactive\ndados_filtrados &lt;- reactive({\n  cat(file = stderr(), \"O código no observe foi executado!\\n\")\n   dados |&gt; \n     dplyr::filter(UF %in% input$uf)\n})\n\n\n# Verificando número de cidades antes de gerar o gráfico\noutput$grafico &lt;- renderPlot({\n  cat(file = stderr(), \"Fazendo gráfico para a renda per capita média de\", nrow(dados_filtrados()), \"cidades\\n\")\n  dados_filtrados() |&gt; \n    dplyr::group_by(ano) |&gt; \n    dplyr::summarise(renda_per_capita_media = mean(renda_per_capita)) |&gt; \n    ggplot2::ggplot(ggplot2::aes(x = ano, y = renda_per_capita_media)) +\n    ggplot2::geom_line()\n})\n\nO \\n ao final das mensagens garante que a próxima mensagem no Console comece em uma nova linha.\n\n\n4.2.2 A função browser()\nEm algumas situações, a gente realmente gostaria de estar dentro da função server durante a sua execução para avaliar quais valores nossos códigos estão recebendo e quais valores eles estão gerando. Graças à função browser() isso é possível!\nCom a função browser(), podemos espiar o que está acontecendo dentro do server quando rodamos o nosso aplicativo. Basta colocar essa função onde você suspeita que o problema está acontecendo e, quando o Shiny passar por ela, a execução do app será pausada e o Console ficará disponível para testes.\nColocando a função browser() dentro de um consumidor reativo (funções da família render*(), por exemplo), você poderá acessar valores da lista input ou expressões reativas geradas com reactive() ou eventReactive().\n\n# server\nvalor_reativo &lt;- reactive({\n  sample(1:10, 1)\n})\n\noutput$plot &lt;- renderPlot({\n  browser()\n  hist(rnorm(100, valor_reativo, 1))\n})\n\n\n# No console\n\n# Browse[1]&gt; valor_reativo()\n# [1] 4\n\nPara sair do browser e voltar à execução do app, basta clicar no botão Continue, no topo do Console. Clicando no botão Stop, tanto o browser quanto a execução do app serão finalizadas. Após encontrar e solucionar o problema, não se esqueça de remover a função browser() do seu código.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Debug</span>"
    ]
  },
  {
    "objectID": "debug.html#exercícios",
    "href": "debug.html#exercícios",
    "title": "4  Debug",
    "section": "4.3 Exercícios",
    "text": "4.3 Exercícios\n1 - Por que, em geral, não conseguimos rodar diretamente o código escrito na função server?\n\n2 - Para que serve a função browser()?\n\n3 - Debug e arrume o código do app a seguir:\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  \"Sorteio de números de 1 a 10\",\n  sliderInput(\n    inputId = \"tamanho\",\n    label = \"Selecione o tamanho da amostra\",\n    min = 1,\n    max = 1000,\n    value = 5\n  ),\n  actionButton(\"sortear\", \"Sortear\"),\n  plotOutput(outputId = \"grafico\"),\n  \"Tabela de frequências\"\n  tableOutput(outputId = \"tabela\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  amostra &lt;- reactive({\n    sample(1:10, input$tamanho)\n  })\n  \n  output$plot &lt;- renderPlot({\n    amostra |&gt; \n      table() |&gt; \n      barplot()\n  })\n  \n  output$tabela &lt;- renderPlot({\n    data.frame(\n      numeros = amostra()\n    ) |&gt; \n      dplyr::count(numeros)\n  })\n  \n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Debug</span>"
    ]
  },
  {
    "objectID": "debug.html#footnotes",
    "href": "debug.html#footnotes",
    "title": "4  Debug",
    "section": "",
    "text": "Também conhecido como debugging (depuração, em português).↩︎\nComo dentro da função renderPrint().↩︎",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Debug</span>"
    ]
  },
  {
    "objectID": "layouts.html",
    "href": "layouts.html",
    "title": "5  Layouts",
    "section": "",
    "text": "5.1 Um pouco sobre HTML\nHTML é uma linguagem de marcação para construir páginas web.\nUma linguagem de marcação é apenas um tipo de documento que contem texto simples (como em um bloco de notas) e um conjunto de instruções para formatar (anotar, marcar) partes específicas do conteúdo. Esse texto simples é então transformado em um texto bem formatado por algum mecanismo que renderiza as instruções. Além do HTML, o LaTeX e o (R) Markdown são outros exemplos comuns de linguagem de marcação bastante utilizadas. No caso do HTML, os navegadores são os responsáveis por renderizar documentos HTML em páginas bem formatadas.\nA maior parte do esforço em aprender uma linguagem de marcação está em aprender quais são e como utilizar as instruções de formatação. No HTML, as instrução de formatação são chamadas tags. Utilizaremos as tags para formatar o texto da página web que estamos criando. Com elas, podemos, por exemplo, transformar um texto em negrito ou itálico, criar títulos e inserir imagens.\nO pacote shiny traz diversas funções para criarmos essas tags. As principais são:\nPodemos utilizar essas funções à vontade na UI para construirmos o layout do nosso app. O código abaixo, por exemplo, gera o código HTML a seguir.\n#ui\nfluidPage(\n  h1(\"Esse é o título do meu app!\", align = \"center\"),\n  hr(),\n  h3(\"Sobre\"),\n  p(\"Lorem ipsum\", tags$em(\"dolor sit amet\", .noWS = \"after\"), \", consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"),\n  p(strong(\"Lorem ipsum dolor\"), \"sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"),\n  hr(),\n  img(src = \"img/logo.png\", width = \"50%\", style = \"display: block; margin: auto;\")\n)\n&lt;div class=\"container-fluid\"&gt;\n  &lt;h1 align=\"center\"&gt;Esse é o título do meu app!&lt;/h1&gt;\n  &lt;hr/&gt;\n  &lt;h3&gt;Sobre&lt;/h3&gt;\n  &lt;p&gt;\n    Lorem ipsum\n    &lt;em&gt;dolor sit amet&lt;/em&gt;, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n  &lt;/p&gt;\n  &lt;p&gt;\n    &lt;strong&gt;Lorem ipsum dolor&lt;/strong&gt;\n    sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n  &lt;/p&gt;\n  &lt;hr/&gt;\n  &lt;img src=\"img/logo.png\" width=\"50%\" style=\"display: block; margin: auto;\"/&gt;\n&lt;/div&gt;\nQue, por sua vez, gera a seguinte UI:\nEsse é o título do meu app!\n\nSobre\n\nLorem ipsum\ndolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n\n\nLorem ipsum dolor\nsit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\nRepare que algumas tags, como a h1 e a img possuem parâmetros (ou atributos, como são chamados no HTML). O parâmetro align na tag h1 faz com que o texto fique alinhado no centro da página. Esse parâmetro é típico das tags de título (h1, …, h6). Outras tags de texto não possuem necessariamente esse argumento.\nJá o argumento src da tag img é utilizado para definirmos o caminho para a imagem que queremos mostrar. O argumento width especifica o comprimento da imagem com relação ao espaço disponível para ela. No exemplo, o logo da Curso-R ocupa 50% do comprimento da página deste livro. O argumento style nos permite formatar ainda mais a imagem a partir de atributos CSS, centralizando a imagem horizontalmente na tela nesse caso.\nConforme aprendemos e utilizamos o Shiny, inevitavelmente aprendemos bastante sobre HTML. Isso aumenta bastante a nossa capacidade de personalizar a UI dos nossos aplicativos e nos ajuda a entender como o Shiny funciona. Por enquanto, vamos manter o foco em explorar as principais ferramentas do Shiny, mas no Capítulo 12 faremos uma breve introdução formal tanto de HTML quanto de CSS.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Layouts</span>"
    ]
  },
  {
    "objectID": "layouts.html#bootstrap",
    "href": "layouts.html#bootstrap",
    "title": "5  Layouts",
    "section": "5.2 Bootstrap",
    "text": "5.2 Bootstrap\nHoje em dia, uma página Web pode ser vista em dispositivos de diferentes tamanhos (celulares, tablets, notebooks, televisões…) e o layout da página deve se adaptar à enorme variedade de tamanho de telas. Isso é um grande desafio para quem desenvolve.\nUma solução seria produzir uma versão para telas pequenas e uma versão para telas grandes, direcionando as visitas para a versão adequada a depender do dispositivo utilizado. Muitos sites utilizam essa alternativa, e você pode verificar isso pela URL. Páginas próprias para dispositivos mobile possuem um m. no início da URL.\nNem sempre essa alternativa é viável, pois produzir duas versões de uma página ou aplicação Web pode ser muito custoso. Nesses casos, a solução é produzir um layout responsivo, isto é, que se adapte a depender do tamanho da tela. É aí que entra o Bootstrap.\nO Bootstrap Framework é uma coleção de códigos CSS que nos ajudam a construir páginas Web responsivas. Boa parte da internet hoje em dia é construída em cima do Bootstrap, e nossos aplicativos Shiny não serão diferentes.\nO Shiny importa o Bootstrap por padrão, isto é, todos os códigos CSS desse framework já estão disponíveis em nossos apps sem precisarmos especificar nada. E a melhor parte é que não precisamos saber CSS para utilizar o Boostrap no Shiny. Só precisamos aprender algumas funções de R.\n\n5.2.1 Grid system\nAntes de vermos essas funções, precisamos entender como funciona o grid system. O Bootstrap estabelece que:\n\nos elementos em uma página serão dispostos primeiramente em linhas;\ncada nova linha será colocada embaixo da anterior;\ncada linha pode ser dividida em até 12 colunas; independentemente do tamanho da tela;\ncada coluna pode ter até 12 unidades de comprimento, sendo que a soma dos comprimentos das colunas de uma linha deve ser no máximo 12;\nquando a tela for pequena o suficiente1 todas as colunas passarão a ter comprimento 12.\n\n\n\n\n\n\nExemplos de layouts que podem ser criados com o grid system.\n\n\n\n\nEm resumo, o conceito por trás do Boostrap estabelece que o layout dos nossos apps serão formados por linhas com até 12 colunas cada. O comprimento de cada coluna pode variar de 1 a 12 unidades e a soma dos comprimentos dessas colunas pode ser no máximo 12. Se o comprimento da tela for menor que um valor limite, todas as colunas automaticamente passam a ter tamanho 12 e os elementos da página passam a ficar um embaixo do outro.\nNo Shiny, para criar novas linhas, utilizamos a função fluidRow(). Para criar colunas dentro de uma linha, utilizamos a função column(). Essa função tem dois argumentos: width e offset. O primeiro determina o comprimento da coluna (de 1 a 12). O segundo indica quanto espaço horizontal gostaríamos de “pular” antes de começar a nossa coluna. A função column() é sempre utilizada dentro da função fluidRow().\nSeguindo esse esquema, passamos a colocar o conteúdo da página dentro das colunas, isto é, dentro da função column().\n\n\n\n\n\nExemplos de layouts que podem ser criados com as funções fluidRow() e column().\n\n\n\n\nUtilizando essas funções, podemos mudar o exemplo da seção anterior e construir o app a seguir:\n\nlibrary(shiny)\n\nfluidPage(\n  fluidRow(\n    column(\n      width = 8,\n      offset = 2,\n      h1(\"Esse é o título do meu app!\", align = \"center\")\n    ),\n    column(\n      width = 2,\n      img(src = \"img/logo.png\", width = \"100%\")\n    )\n  ),\n  hr(),\n  h3(\"Sobre\"),\n  fluidRow(\n    column(\n      width = 6,\n      p(\"Lorem ipsum\", tags$em(\"dolor sit amet\", .noWS = \"after\"), \", consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\")\n    ),\n    column(\n      width = 6,\n      p(strong(\"Lorem ipsum dolor\"), \"sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\")\n    )\n  ),\n  hr(),\n  fluidRow(\n    column(\n      width = 6,\n      offset = 3,\n      img(src = \"img/logo.png\", width = \"100%\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n}\n\nshinyApp(ui, server)\n\n\n\n\n\n\n\n\n\n\nRepare que agora a imagem no fim da página foi centralizada utilizando as funções fluidRow() e column(). Não foi mais necessário definir CSS diretamente para realizar essa tarefa. Como exercício, rode esse app e veja o que acontece com a página conforme você diminui o comprimento da tela.\n\n\n5.2.2 Fluid grid vs Fixed grid\nAgora que sabemos um pouco sobre Boostrap, podemos falar por que construímos a nossa UI dentro da função fluidPage().\nAo rodar essa função, vemos que ela devolve o seguinte código HTML.\n\nfluidPage()\n\n\n&lt;div class=\"container-fluid\"&gt;&lt;/div&gt;\n\nA classe container-fluid aplicada ao elemento &lt;div&gt; é a explicação. Classes são utilizadas no HTML para atribuir propriedades a elementos da página. Essa classe em específico contém parte do código CSS necessário para a responsividade do Bootstrap funcionar.\nEm resumo, o Boostrap fala que o conteúdo da página precisa estar dentro de um elemento (&lt;div&gt;) com classe col, que por sua vez deve estar dentro de um elemento com classe row e que, por fim, deve estar dentro de um elemento com classe container.\nVeja que é exatamente isso que acontece quando escrevemos o código abaixo:\n\nfluidPage(\n  fluidRow(\n    column(\n      width = 4,\n      \"O conteúdo do app vem aqui.\"\n    )\n  )\n)\n\n\n&lt;div class=\"container-fluid\"&gt;\n  &lt;div class=\"row\"&gt;\n    &lt;div class=\"col-sm-4\"&gt;O conteúdo do app vem aqui.&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\nRepare que a classe col é acompanhada de mais dois valores. O 4 representa o tamanho da coluna (foi esse o tamanho definido pela função column()). Já o sm representa o quão estreita precisa ser a tela do dispositivo para que a responsividade seja ativada. O termo sm é diminutivo para small, indicando que se a tela for menor que 750px, todas as colunas terão comprimento 12. Esse é o padrão no Shiny e não pode ser alterado por meio da função column(). Você pode saber mais sobre a classe col lendo a documentação do Boostrap.\nA classe container também possui um qualificador: fluid. Isso porque existem dois tipos de grades Boostrap: fluid e fixed. Páginas construídas com a grade fluida sempre ocuparão todo o comprimento da tela, redimensionando os seus elementos dinamicamente caso o comprimento da tela mude. Já a grade fixa ocupa sempre um tamanho fixo da tela: 724px, 940px ou 1170px, a depender do quão grande for a tela. O conteúdo sempre ficará centralizado e o espaço restante ficará em branco, como uma margem aos lados.\nPodemos criar um app com grade fixa utilizando a função fixedPage() no lugar da fluidPage().",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Layouts</span>"
    ]
  },
  {
    "objectID": "layouts.html#layouts-prontos",
    "href": "layouts.html#layouts-prontos",
    "title": "5  Layouts",
    "section": "5.3 Layouts prontos",
    "text": "5.3 Layouts prontos\nO pacote shiny fornece alguns layouts prontos para serem usados. Os principais são:\n\nsidebarLayout(): para criar um aplicativo com uma barra lateral;\nnavbarPage(): para criar um aplicativo com um menu de navegação no topo da tela;\nnavlistPanel(): para criar um menu de navegação lateral;\n\nTambém falaremos nesta seção de layouts que não estão no pacote shiny. São eles:\n\nshinydashboard: possui um layout com menu navegação lateral e diversos elementos visuais extras;\nbs4Dash: cria o mesmo layout que o shinydashboard, mas utiliza uma versão mais recente do Boostrap.\n\nA seguir, vamos falar com mais detalhes de cada um deles.\n\n5.3.1 sidebarLayout\nO sidebarLayout é um layout bem simples, para apps com poucas visualizações. Ele possui uma barra lateral, onde geralmente colamos os inputs, e uma área principal, onde colocamos os outputs. A figura abaixo mostra um app sem conteúdo, mas construído com sidebarLayout.\n\n\n\n\n\n\n\n\n\nPara criar esse layout, utilizamos a estrutura a seguir.\n\nui &lt;- fluidPage(\n  titlePanel(\"Shiny com sidebarLayout\"),\n  sidebarLayout( \n    sidebarPanel(\n      sliderInput(\n        \"num\",\n        \"Número de observações:\",\n        min = 0,\n        max = 1000,\n        value = 500\n      )\n    ),\n    mainPanel(\n      plotOutput(\"hist\")\n    )\n  )\n)\n\n\nTodos os elementos do layout são colocados dentro da função fluidPage().\nA função titlePanel() é utilizada para inserirmos um título no app.\nEspecificamos o layout com a função sidebarLayout().\nCriamos uma barra lateral com a função sidebarPanel().\nDentro do sidebarPanel(), colocamos tudo o que queremos que apareça na barra lateral. No exemplo, teremos um slider.\nPor fim, utilizamos a função mainPanel() para especificar tudo o que aparecerá na área principal do app. No exemplo, teremos apenas um gráfico.\n\n\n\n5.3.2 navbarPage\nO navbarPage é um layout dividido em páginas, muito útil para organizar o conteúdo de apps mais maiores, com muitas visualizações. Ele possui uma barra de navegação superior, onde é possível colocar um título e acessar cada uma das páginas do app. A figura abaixo mostra um app construído com esse layout.\n\n\n\n\n\n\n\n\n\nApesar do nome, um aplicativo construído com navbarPage não possui de fato várias páginas. No fundo, esse app será composto por um único arquivo HTML, contendo o código de todas as abas. Não estamos acessando páginas diferentes (a URL não muda), mas sim acessando partes de uma mesma página que ficam escondidas enquanto não olhamos para elas.\nPara criar um layout com menu de navegação superior, utilizamos a função navbarPage(), com a estrutura a seguir.\n\nui &lt;- navbarPage(\n  title = \"Shiny com navbarPage\",\n  tabPanel(title = \"Painel 1\"),\n  tabPanel(title = \"Painel 2\"),\n  tabPanel(title = \"Painel 3\"),\n  navbarMenu(\n    title = \"Mais opções\",\n    tabPanel(title = \"Item 1\"),\n    tabPanel(title = \"Item 2\"),\n    tabPanel(title = \"Item 3\")\n  )\n)\n\n\nTodo o código fica agora dentro da função navbarPage(). Não precisamos utilizar aqui a função fluidPage(). Além da barra de navegação, a função navbarPage() cria uma página com grade fluida.\nCom a função tabPanel(), criamos as diferentes páginas do aplicativo, que são acessadas pela barra superior. O argumento title indica o título que aparecerá em cada botão.\nA função navbarMenu() nos permite agrupar opções de página em uma caixinha de seleção.\nOs itens desse menu também são criados pela função tabPanel(), colocadas dentro da função navbarMenu().\nOs inputs e outputs (e qualquer outro elemento da página) são colocados dentro de cada tabPanel().\n\n\n\n5.3.3 navlistPanel\nSe você prefere menus laterais, você consegue um efeito parecido com o do navbarPage() utilizando a função navlistPanel().\nA figura abaixo mostra um app construído com esse menu lateral.\n\n\n\n\n\n\n\n\n\nPara criar esse layout, utilizamos a função navlistPanel() como mostrado a seguir.\n\nui &lt;- fluidPage(\n  titlePanel(\"App com navlistPanel\"),\n  navlistPanel(\n    widths = c(2, 10),\n    tabPanel(\n      title = \"Página 1\",\n      \"Conteúdo da página 1\"\n    ),\n    tabPanel(\n      title = \"Página 2\",\n      \"Conteúdo da página 2\"\n    ),\n    tabPanel(\n      title = \"Página 3\",\n      \"Conteúdo da página 3\"\n    )\n  )\n)\n\n\nPodemos usar o navlistPanel em qualquer tipo de página/layout. Aqui utilizamos dentro de uma fluidPage simples.\nCada página do app é colocada dentro de uma tabPanel() dentro da função navlistPanel(), igual no navbarPage (o conceito de “página” também é o mesmo).\nO argumento widths da função navlistPanel() determina quanto espaço a barra lateral e a área reservada para o conteúdo (à direita) vão ocupar. Você deve passar dois valores de 1 a 12, somando 12 no total.\n\n\n\n5.3.4 shinydashboard\nO shinydasboard é um pacote que introduz diversas ferramentas para o Shiny. Antes de mais nada, instale o pacote:\n\ninstall.packages(\"shinydasboard\")\n\nA principal é um novo layout, dividido em três áreas:\n\no header, uma barra superior onde podemos colocar títulos, botões e links;\no sidebar, uma barra lateral onde podemos colocar um menu de navegação, logos e textos;\no body, a área do app onde construímos o conteúdo em si (inputs e outputs).\n\nA figura a seguir mostra o layout básico de um shinydasboard.\n\n\n\n\n\n\n\n\n\nPara construir esse layout, utilizamos o seguinte código:\n\nlibrary(shinydashboard)\n\nui &lt;- dashboardPage(\n  dashboardHeader(),\n  dashboardSidebar(),\n  dashboardBody()\n)\n\nserver &lt;- function(input, output, session) {\n  \n}\n\nshinyApp(ui, server)\n\n\nA função dashboardPage() é responsável por criar a página do shinydashboard. Ela recebe três funções como argumentos: dashboardHeader(), dashboardSidebar() e dashboardBody().\nA função dashboardHeader() é responsável por elementos da barra superior (azul).\nA função dashboardSidebar() é responsável por elementos da barra lateral (preta). Geralmente colocamos um menu para criar várias páginas no nosso dashboard, mas também é possível colocar imagens, logos e, embora seja incomum, até inputs e outputs.\nA função dashboardBody() controla os elementos da área principal do app (cinza). É nela que desenvolveremos o conteúdo do nosso app.\n\nPara construir um menu na barra lateral, utilizamos a função sidebarMenu() dentro da função dashboardSidebar(). Cada item do menu é criado pela função menuItem(). Ao argumento text, passamos o nome que será apresentado na tela. Já ao tabName, passamos um código que será utilizado para nos referirmos a esse item de menu dentro da função dashboardBody(), para podermos construir o conteúdo dele.\n\ndashboardSidebar(\n  sidebarMenu(\n    menuItem(text = \"Página 1\", tabName = \"pagina1\"),\n    menuItem(text = \"Página 2\", tabName = \"pagina2\")\n  )\n)\n\nDentro do dashboardBody() usamos a função tabItems() para listar os itens do menu. O conteúdo das páginas é criado utilizando a função tabItem(). Precisamos passar para essa função o argumento tabName, para nos referirmos a qual item do menu pertence o conteúdo de cada tabItem(). No código abaixo, substituiríamos o ... pelos inputs e outputs que quisermos construir em cada página do dashboard.\n\n# ui\ndashboardBody(\n  tabItems(\n    tabItem(tabName = \"pagina1\", ...),\n    tabItem(tabName = \"pagina2\", ...)\n  )\n)\n\nAssim, o código da ui ficaria:\n\nui &lt;- dashboardPage(\n  dashboardHeader(),\n  dashboardSidebar(\n    sidebarMenu(\n      menuItem(\"Página 1\", tabName = \"pagina1\"),\n      menuItem(\"Página 2\", tabName = \"pagina2\")\n    )\n  ),\n  dashboardBody(\n    tabItems(\n      tabItem(tabName = \"pagina1\", ...),\n      tabItem(tabName = \"pagina2\", ...)\n    )\n  )\n)\n\nAlém do layout de dashboard, o pacote shinydashboard trás novos elementos para a UI, como o box() e o tabBox().\nA função box() cria caixinhas que permitem separarmos conteúdo do restante da página.\n\nfluidRow(\n  box(\n    title = \"Histograma\",\n    status = \"primary\",\n    solidHeader = TRUE,\n    collapsible = TRUE,\n    ... # conteúdo do box\n  )\n)\n\nfluidRow(\n  box(\n    title = \"Inputs\",\n    status = \"warning\",\n    solidHeader = TRUE,\n    ... # conteúdo do box\n  )\n)\n\n\n\n\n\n\n\n\n\n\nSe olharmos o código HTML gerado por um box(), notamos que essas estruturas são colunas dentro do Bootstrap. Por essa razão, a função box() deve sempre estar dentro de uma fluidRow(), como fizemos no código acima.\n\nbox()\n\n\n&lt;div class=\"col-sm-6\"&gt;\n  &lt;div class=\"box\"&gt;\n    &lt;div class=\"box-body\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\nO tabBox() permite a criação de caixinhas com abas, possibilitando a divisão de conteúdo em várias camadas que ocupam o mesmo espaço da tela. No código abaixo, substituiríamos o ... pelo conteúdo de cada aba.\n\nfluidRow(\n  tabBox(\n    tabPanel(\"Aba 1\", ...),\n    tabPanel(\"Aba 2\", ...),\n    tabPanel(\"Aba 3\", ...)\n  )\n)\n\n\n\n\n\n\n\n\n\n\nA estrutura criada pelo tabBox() também é uma coluna no contexto do Boostrap, então também deve estar sempre dentro de uma fluidRow().\n\ntabBox()\n\n\n&lt;div class=\"col-sm-6\"&gt;\n  &lt;div class=\"nav-tabs-custom\"&gt;\n    &lt;ul class=\"nav nav-tabs\" data-tabsetid=\"4764\"&gt;&lt;/ul&gt;\n    &lt;div class=\"tab-content\" data-tabsetid=\"4764\"&gt;&lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\nO pacote shinydashboard também possui novos outputs: o valueBox() e o infoBox(). Ambos servem para a criação de caixinhas coloridas para destacar valores. Para utilizá-las no Shiny, usamos a combinação valueBoxOutput()/renderValueBox()\n\n\n\n\n\n\n\n\n\ne infoBoxOutput()/renderInfoBox().\n\n\n\n\n\n\n\n\n\nDentro de cada função render, utilizamos as funções valueBox() e infoBox() para criar as caixinhas.\nComo as funções valueBox() e infoBox() retornam HTML, podemos utilizá-las diretamente na ui (sem output/render) caso esse conteúdo não dependa de valores reativos.\nPara saber mais sobre o shinydashboard, acesso o site do pacote. Para inspiração de como usar esse layout, confira a galeria de exemplos.\n\n\n5.3.5 bs4Dash\nO pacote bs4Dash é uma outra opção para construir um layout com menu de navegação lateral. Ele se diferencia do shinydashboard por utilizar uma versão do Bootstrap mais recente: ele utiliza a versão 4, enquanto o shinydashboard a 3.\nPara instalar o pacote, utilize o código a seguir:\n\ninstall.packages(\"bs4Dash\")\n\nA construção do layout com o pacote bs4Dash é equivalente ao que vimos com o shinydashboard.\n\nlibrary(bs4Dash)\n\nui &lt;- bs4DashPage(\n  bs4DashNavbar(),\n  bs4DashSidebar(\n    bs4SidebarMenu(\n      bs4SidebarMenuItem(\"Página 1\", tabName = \"pagina1\"),\n      bs4SidebarMenuItem(\"Página 2\", tabName = \"pagina2\")\n    )\n  ),\n  bs4DashBody(\n    tabItems(\n      tabItem(tabName = \"pagina1\",...),\n      tabItem(tabName = \"pagina2\",...)\n    )\n  )\n)\n\nA maioria das funções do bs4Dash possuem aliases com nomes iguais aos do shinydashboard. Isso significa que você pode construir um bs4dash usando praticamente o mesmo código de um shinydashboard, mudando apenas o pacote que está sendo carregado no início.\n\n# Esse código gera a ui de um bs4Dash\nlibrary(bs4Dash)\n\nui &lt;- dashboardPage(\n  dashboardHeader(),\n  dashboardSidebar(\n    sidebarMenu(\n      menuItem(\"Página 1\", tabName = \"pagina1\"), #&lt;&lt;\n      menuItem(\"Página 2\", tabName = \"pagina2\")\n    )\n  ),\n  dashboardBody(\n    tabItems(\n      tabItem(tabName = \"pagina1\",...), #&lt;&lt;\n      tabItem(tabName = \"pagina2\",...)\n    )\n  )\n)\n\nO pacote bs4Dash também possui diversos outros elementos para complementar a construção dos nossos apps. Você pode ver um exemplo da maioria deles e do bs4Dash como um todo neste exemplo de demonstração.\nPara mais informações sobre o bs4Dash, acesse a vignette do pacote.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Layouts</span>"
    ]
  },
  {
    "objectID": "layouts.html#adicionando-css",
    "href": "layouts.html#adicionando-css",
    "title": "5  Layouts",
    "section": "5.4 Adicionando CSS",
    "text": "5.4 Adicionando CSS\nVocê pode customizar o visual do seu aplicativo utilizando CSS. Nesta seção, falaremos apenas como adicionar CSS ao Shiny. Uma introdução formal ao CSS será feita no Capítulo Capítulo 12.\nA melhor maneira de adicionar CSS a elementos HTML de um aplicativo Shiny é escrever o código em um arquivo .css e referenciá-lo na seção &lt;head&gt;.\nPara fazer isso, primeiro crie um arquivo de texto com extensão .css e salve dentro da pasta /www. A pasta /www deve estar na mesma pasta que o .R que gera o aplicativo e é nela que colocamos os arquivos que o navegador poderá ter acesso enquanto roda o app.\nNesse arquivo, coloque a seguinte regra CSS:\n\nbody {\n  background-color: lightblue;\n}\n\nNo seu app, supondo que o arquivo se chama custom.css, ele deverá ser referenciado dentro da UI da seguinte forma:\n\nui &lt;- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", href = \"custom.css\")\n  )\n)\n\nA função tags$head() indica que o código HTML colocado dentro dela será inserido no final da seção &lt;head&gt; do HTML. É sempre nessa seção que referenciamos arquivos CSS externos. A função tags$link() serve para referenciarmos o arquivo CSS ao HTML, sendo que o argumento rel = \"stylesheet\" indica que esse arquivo deverá ser encarado pelo HTML como uma folha de estilo.\nNo arquivo CSS, você pode colocar quantas regras CSS você precisar.\n\nbody {\n  background-color: lightblue;\n}\n\nh1 {\n  color: purple;\n}\n\np {\n  font-size: 12pt;\n}",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Layouts</span>"
    ]
  },
  {
    "objectID": "layouts.html#exercícios",
    "href": "layouts.html#exercícios",
    "title": "5  Layouts",
    "section": "5.5 Exercícios",
    "text": "5.5 Exercícios\n1 - O que é uma linguagem de marcação?\n\n2 - Como criar as tags HTML usando o pacote shiny?\n\n3 - O que é o framework Bootstrap? O que é o sistema de grade (grid system)?\n\n4 - Refaça os apps dos exercícios dos capítulos anteriores utilizando o sidebarLayout.\n\n5 - Utilizando a base dados::clima e o layout navbarPage, faça um shiny app que tenha duas páginas:\n\na primeira com uma série temporal da média diária da temperatura, permitindo a escolha do intervalo de dias em que o gráfico é gerado\na segunda com uma caixa de seleção permitindo escolher as opções umidade, velocidade_vento e precipitacao e um gráfico de dispersão da temperatura contra a variável escolhida.\n\n\n6 - Transforme o aplicativo construído no exercício anterior em um shinydasbhoard.\n\n7 - Transforme o aplicativo construído no exercício anterior em um bs4Dash.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Layouts</span>"
    ]
  },
  {
    "objectID": "layouts.html#footnotes",
    "href": "layouts.html#footnotes",
    "title": "5  Layouts",
    "section": "",
    "text": "Você pode conferir os tamanhos limites na documentação do Bootstrap: https://getbootstrap.com.br/docs/4.1/getting-started/introduction/)↩︎",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Layouts</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-1.html",
    "href": "shiny-na-pratica-1.html",
    "title": "6  Shiny na prática I",
    "section": "",
    "text": "6.1 Importando bases de dados\nA tarefa de importação de dados dentro do Shiny não possui nenhum desafio particular. Podemos seguir lendo nossos dados, seja de arquivos locais, da internet ou de banco de dados, da mesma maneira que fazemos em scripts R habituais.\nA única questão importante é onde fazer isso.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Shiny na prática I</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-1.html#importando-bases-de-dados",
    "href": "shiny-na-pratica-1.html#importando-bases-de-dados",
    "title": "6  Shiny na prática I",
    "section": "",
    "text": "6.1.1 Importar fora da função server\nQuando importamos os nossos dados fora da função server, podemos utilizá-los também na construção da UI. Essa opção é a ideal para quando os seus dados não mudam com o tempo. Veja um exemplo a seguir.\n\nlibrary(shiny)\n\nlink &lt;- \"https://raw.githubusercontent.com/williamorim/brasileirao/master/data-raw/csv/matches.csv\"\n\ndados &lt;- readr::read_csv(link)\n\nui &lt;- fluidPage(\n  titlePanel(\"Últimos 10 jogos do time\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        \"time\",\n        label = \"Selecione um time\",\n        choices = unique(dados$home)\n      )\n    ),\n    mainPanel(\n      tableOutput(\"tabela\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$tabela &lt;- renderTable({\n    dados |&gt;\n      dplyr::filter(\n        score != \"x\",\n        home == input$time | away == input$time\n      ) |&gt;\n      dplyr::slice_max(order_by = date, n = 10) |&gt;\n      dplyr::mutate(\n        date = format(date, \"%d/%m/%Y\")\n      ) |&gt;\n      dplyr::select(date, home, score, away)\n  })\n  \n}\n\nshinyApp(ui, server)\n\n\n\n6.1.2 Importando dentro da função server\nVocê pode importar uma base de dados normalmente dentro da função server. Nesse caso, não temos acesso aos dados na construção da UI. Veja no exemplo a seguir que precisamos construir o selectInput dentro da UI utilizando a dupla de funções uiOutput() e renderUI().\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Últimos 10 jogos do time\"),\n  sidebarLayout(\n    sidebarPanel(\n      uiOutput(\"select_time\")\n    ),\n    mainPanel(\n      tableOutput(\"tabela\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  link &lt;- \"https://raw.githubusercontent.com/williamorim/brasileirao/master/data-raw/csv/matches.csv\"\n  \n  dados &lt;- readr::read_csv(link)\n  \n  output$select_time &lt;- renderUI({\n    selectInput(\n      \"time\",\n      label = \"Selecione um time\",\n      choices = unique(dados$home)\n    )\n  })\n  \n  output$tabela &lt;- renderTable({\n    dados |&gt;\n      dplyr::filter(\n        score != \"x\",\n        home == input$time | away == input$time\n      ) |&gt;\n      dplyr::slice_max(order_by = date, n = 10) |&gt;\n      dplyr::mutate(\n        date = format(date, \"%d/%m/%Y\")\n      ) |&gt;\n      dplyr::select(date, home, score, away)\n  })\n  \n}\n\nshinyApp(ui, server)\n\nQuando rodamos esse app, um erro aparece por uma fração de segundos no lugar da tabela. Isso acontece pois, no momento em que o Shiny tenta gerar a tabela pela primeira vez, o input$time ainda não existe, ele ainda está sendo criado pelo renderUI(). Veremos como lidar com isso na seção de validação do Capítulo 7.\nDevemos ler os dados dentro da função server quando eles forem atualizados frequentemente, pois dessa maneira eles serão importados no momento em que cada pessoa acessar o app. Importar dentro da função server também vai ser necessário quando a leitura dos dados depender de um valor reativo.\nNo exemplo a seguir, simulamos a conexão com um banco de dados para a leitura das partidas. Também permitimos a escolha da temporada antes da escolha do time. Os dados requisitados ao banco são apenas os da temporada escolhida, diminuindo a quantidade de dados transmitidos. Nesse caso, o objeto dados passa a ser uma expressão reativa, pois ele depende do input$temporada.\n\n# Esse exemplo não pode ser rodado,\n# pois a função conectar_com_o_banco()\n# não existe.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Últimos 10 jogos do time\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        \"temporada\",\n        label = \"Selecione uma temporada\",\n        choices = 2003:2022\n      ),\n      uiOutput(\"select_time\")\n    ),\n    mainPanel(\n      tableOutput(\"tabela\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  dados &lt;- reactive({\n    con &lt;- conectar_com_o_banco()\n    dplyr::tbl(con, \"partidas\") |&gt; \n      dplyr::filter(season == input$temporada) |&gt; \n      dplyr::collect()\n  })\n  \n  output$select_time &lt;- renderUI({\n    selectInput(\n      \"time\",\n      label = \"Selecione um time\",\n      choices = unique(dados()$home)\n    )\n  })\n  \n  output$tabela &lt;- renderTable({\n    dados() |&gt;\n      dplyr::filter(\n        score != \"x\",\n        home == input$time | away == input$time\n      ) |&gt;\n      dplyr::slice_max(order_by = date, n = 10) |&gt;\n      dplyr::mutate(\n        date = format(date, \"%d/%m/%Y\")\n      ) |&gt;\n      dplyr::select(date, home, score, away)\n  })\n  \n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Shiny na prática I</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-1.html#sec-ggplot2",
    "href": "shiny-na-pratica-1.html#sec-ggplot2",
    "title": "6  Shiny na prática I",
    "section": "6.2 Gráficos com ggplot2",
    "text": "6.2 Gráficos com ggplot2\nGráficos são a alegria da festa na hora de comunicarmos os resultados de uma análise de dados. Embora possamos usar tabelas, textos ou caixinhas coloridas com valores para comunicar nossos resultados, são eles que geralmente chamam e prendem a atenção de quem está utilizando o app.\nO pacote ggplot2 é uma ótima ferramenta para produzirmos gráficos no R. Quando entendemos a sua sintaxe, nos tornamos capazes de fazer uma variedade enorme de gráficos e dar a eles a cara que quisermos.\nNada do que o pacote ggplot2 tem para oferecer se perde quando estamos construindo gráficos dentro de um Shiny app. Pelo contrário, ainda ganhamos um novo recurso!\nPara inserir um ggplot em um aplicativo Shiny, utilizamos a dupla de funções plotOutput()/renderPlot(). Essas funções estão preparadas para receber um objeto gerado pelas funções do ggplot e renderizá-lo em uma imagem, que será inserida no HTML do app por meio da tag &lt;img&gt;. Veja um exemplo abaixo.\n\nlibrary(shiny)\nlibrary(ggplot2)\n\ncolunas &lt;- names(mtcars)\n\nui &lt;- fluidPage(\n  titlePanel(\"Shiny app com um ggplot\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        \"varX\",\n        label = \"Variável eixo X\",\n        choices = colunas\n      ),\n      selectInput(\n        \"varY\",\n        label = \"Variável eixo Y\",\n        choices = colunas,\n        selected = colunas[6]\n      )\n    ),\n    mainPanel(\n      plotOutput(\"grafico\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  output$grafico &lt;- renderPlot({\n    ggplot(mtcars, aes(x = .data[[input$varX]], y = .data[[input$varY]])) +\n      geom_point()\n  })\n}\n\nshinyApp(ui, server)\n\n\n\n\n\n\nApp com dois inputs especificando as variáveis do eixo x e y de um ggplot .\n\n\n\n\nO objeto gerado pela função ggplot() é uma lista com classe gg e ggplot, que contém todas as informações necessárias para o R desenhar o gráfico.\n\nlibrary(ggplot2)\n\np &lt;- ggplot(mtcars, aes(x = wt, y = mpg)) +\n  geom_point()\n\nclass(p)\n\n[1] \"gg\"     \"ggplot\"\n\nnames(p)\n\n[1] \"data\"        \"layers\"      \"scales\"      \"mapping\"     \"theme\"      \n[6] \"coordinates\" \"facet\"       \"plot_env\"    \"labels\"     \n\n\nRepare que, se salvássemos o ggplot em um arquivo (.png por exemplo), poderíamos simplesmente usar a dupla imageOutput()/renderImage() para inserir um gráfico no nosso app, já que essas funções também criam uma tag &lt;img&gt;, mas a partir de um arquivo de imagem local.\nMas não precisar salvar o ggplot em um arquivo não é a única vantagem de utilizarmos as funções plotOutput()/renderPlot(). Essas funções inserem um objeto intermediário no diagrama de reatividade do app: o plotObj. Esse objeto é justamente a lista gerada pelas funções que utilizamos na construção do gráfico e que só é recalculado quando um dos inputs existentes no código da função renderPlot() muda.\nJá o gráfico renderizado depende não apenas desse plotObj, mas também do comprimento e altura da janela do navegador de quem estiver utilizando o app. Dessa maneira, o gráfico é renderizado não apenas quando o plotObj muda, mas também quando o espaço disponível para a tag &lt;img&gt; na tela muda. Nesse segundo caso, o R gera o gráfico novamente, redesenhando seus elementos para a nova proporção de comprimento e altura. E o melhor é que ele faz isso sem precisar rodar o código da função renderPlot() novamente, pois tudo o que ele precisa já está salvo no plotObj.\n\n\n\n\n\nGráfico sendo redimensionado conforme diminuímos o comprimento da tela.\n\n\n\n\nSem esse recurso, nossos gráficos seriam apenas imagens sendo esticadas e achatadas, o que provavelmente os deixaria pixelados. Ao contrário do que acontece no R Markdown, em um relatório HTML ou em um flexdashboard por exemplo, no Shiny não precisamos nos preocupar muito com as dimensões de um ggplot. Ele será sempre automaticamente otimizado para o espaço disponível na tela.\nMas nem tudo são flores… Por melhor que consigamos mexer no visual do nosso ggplot utilizando a função theme(), no fim do dia ele continuará sendo apenas uma imagem no nosso app. Isso significa que não será possível atribuir a ele qualquer comportamento interativo, como tooltips, drildown ou ações geradas por cliques no gráfico. Para isso, precisaremos utilizar as bibliotecas gráficas próprias para a Web, que utilizam JavaScript para criar esses recursos. Falaremos sobre elas no Capítulo 8.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Shiny na prática I</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-1.html#animações-de-carregamento",
    "href": "shiny-na-pratica-1.html#animações-de-carregamento",
    "title": "6  Shiny na prática I",
    "section": "6.3 Animações de carregamento",
    "text": "6.3 Animações de carregamento\nÉ muito comum termos visualizações no nosso app que demoram para serem geradas. Quando estamos carregando o app, isso pode fazer com que parte da UI fique em branco, parecendo que a página está quebrada ou fazendo com que alguém passe em branco pelo output que você teve tanto trabalho para fazer. Quando a visualização está sendo recalculada, o padrão do Shiny é deixar a versão anterior acinzentada até que a nova apareça, o que pode gerar estranheza e também passar a ideia de que o aplicativo quebrou.\nÉ uma boa prática sempre avisarmos a quem estiver usando o app que alguma coisa está acontecendo por trás das cortinas. Quando a espera é muito longa, devemos sempre que possível explicar o porquê a pessoa está esperando e dar uma estimativa do tempo. Nesses casos, barras de carregamento são a melhor alternativa. Falaremos delas na próxima seção.\nQuando a espera não é tão grande (entre 2 e 10 segundos, por exemplo), animações giratórias ou de looping infinito podem ser utilizadas para indicar que algo vai aparecer ali e reduzir um pouco a percepção do tempo de espera.\nNesta seção, falaremos de dois pacotes que deixam muito simples a tarefa de incluir essas animações em nossos outputs: o shinycssloaders e o shinyWidgets.\nSe você ainda não tem esses pacotes instalados, ambos estão no CRAN:\n\ninstall.packages(\"shinycssloaders\")\ninstall.packages(\"shinyWidgets\")\n\nO shinycssloaders é um pacote mantido pelo Dean Attali que possui uma única função: withSpinner(). Para colocar a animação de carregamento em uma visualização, basta colocar a função *Output() dentro da função withSpinner(). Sempre que ela estiver sendo calculada, um spinner será mostrado no lugar.\nRode o Shiny app abaixo para ver um exemplo:\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Exemplo shinyWidgets::addSpinner\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"variavel\",\n        label = \"Escolha uma variável\",\n        choices = names(mtcars)\n      )\n    ),\n    mainPanel(\n      shinycssloaders::withSpinner(\n        plotOutput(outputId = \"histograma\"),\n        type = 4,\n        color = \"orange\",\n        size = 2\n      )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$histograma &lt;- renderPlot({\n    Sys.sleep(5)\n    hist(mtcars[[input$variavel]])\n  })\n  \n  \n}\n\nshinyApp(ui, server)\n\nAlém várias opções de animações diferentes, que você pode trocar no argumento type, também é possível ajustar o tamanho, a cor, a cor de fundo e até usar uma imagem própria como animação1.\nO pacote shinyWidgets é mantido pela equipe da dreamRs. Além de diversos widgets muito úteis, ele possui a função shinyWidgets::addSpinner(). Assim como a função shinycssloards::withSpinner(), basta embrulhar suas funções *Output() com a função shinyWidgets::addSpinner() para adicionar a animação às suas visualizações.\nSão diversas opções de animação, escolhidas por meio do argumento spin. Aqui você pode customizar apenas a cor delas. Rode o app a seguir para ver um exemplo.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Exemplo shinyWidgets::addSpinner\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        inputId = \"variavel\",\n        label = \"Escolha uma variável\",\n        choices = names(mtcars)\n      )\n    ),\n    mainPanel(\n      shinyWidgets::addSpinner(\n        plotOutput(outputId = \"histograma\"),\n        spin = \"cube\",\n        color = \"purple\"\n      )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  output$histograma &lt;- renderPlot({\n    Sys.sleep(5)\n    hist(mtcars[[input$variavel]])\n  })\n  \n  \n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Shiny na prática I</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-1.html#barras-de-carregamento",
    "href": "shiny-na-pratica-1.html#barras-de-carregamento",
    "title": "6  Shiny na prática I",
    "section": "6.4 Barras de carregamento",
    "text": "6.4 Barras de carregamento",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Shiny na prática I</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-1.html#usando-markdown-para-textos",
    "href": "shiny-na-pratica-1.html#usando-markdown-para-textos",
    "title": "6  Shiny na prática I",
    "section": "6.5 Usando Markdown para textos",
    "text": "6.5 Usando Markdown para textos\nÉ comum precisarmos colocar em nossos aplicativos páginas com orientações, informações adicionais ou referências.\nEssas páginas geralmente são compostas por textos, links e imagens, facilmente produzidos em um arquivo Markdown. Construir esses elementos HTML dentro da UI dá bem mais trabalho, pois tudo precisa ser encapsulado por funções da lista shiny::tags$.\nPor exemplo, vamos supor que queiramos colocar a seguinte mini bio em um app que estamos fazendo.\n\n\n\nRick Sanchez\nProcurado por crimes contra o espaço interdimensional. Saiba mais aqui.\n\n \nO arquivo Markdown para construir essa mini bio seria bem simples:\n&lt;center&gt;\n&lt;img src=\"img/rick.jpeg\" width=\"130px\" style=\"border-radius: 65px;\"/&gt;\n\n**Rick Sanchez**\n\nProcurado por crimes contra o espaço interdimensional. Saiba mais [aqui](https://rickandmorty.fandom.com/wiki/Rick_Sanchez).\n&lt;/center&gt;\nConstruir a mesma minibio na UI é bem mais burocrático.\n\nfluidPage(\n  fluidRow(\n    column(\n      width = 12,\n      shiny::tags$img(\n        src = \"img/rick.jpeg\",\n        width = \"130px\",\n        style = \"border-radius: 65px; display: block; margin: auto;\"\n      ),\n      shiny::tags$p(\n        shiny::tags$strong(\"Rick Sanchez\"),\n        style = \"text-align: center;\"\n      ),\n      shiny::tags$p(\n        style = \"text-align: center;\",\n        \"Procurado por crimes contra o espaço interdimensional. Saiba mais\",\n        shiny::tags$a(\n          href = \"https://rickandmorty.fandom.com/wiki/Rick_Sanchez\",\n          \"aqui\"\n        )\n      )\n    )\n  )\n)\n\nMesmo um exemplo simples já começa a deixar claro o problema: produzir muitos elementos HTML na UI rapidamente transforma seu código em um emaranhado de funções aninhadas. O mesmo vale para textos muito grandes. Embora nesse caso nem sempre tenhamos muitas tags HTML para criar, scripts R não foram feitos para atender os cuidados que textos carecem.\nA melhor prática nessas situações é justamente transferir esses elementos para um arquivo Markdown e pedir que o Shiny o transforme em HTML e o inclua no lugar adequado apenas na hora do runApp(). Para isso usamos a função shiny::includeMarkdown().\nSupondo que salvamos o markdown da mini bio em um arquivo rick.md, a nossa UI então ficaria:\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(\n      width = 12,\n      includeMarkdown(\"rick.md\")\n    )\n  )\n)\n\nVale ressaltar que essa função compila arquivos Markdown (.md) e não R Markdown (.Rmd). Se quisermos rodar códigos R para gerar saídas HTML, devemos fazer isso dentro do próprio Shiny.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Shiny na prática I</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-1.html#footnotes",
    "href": "shiny-na-pratica-1.html#footnotes",
    "title": "6  Shiny na prática I",
    "section": "",
    "text": "Pode ser uma imagem estática ou GIF.↩︎",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Shiny na prática I</span>"
    ]
  },
  {
    "objectID": "reatividade-mais-pecas.html",
    "href": "reatividade-mais-pecas.html",
    "title": "7  Reatividade: mais peças",
    "section": "",
    "text": "7.1 Mais funções observadoras\nAs funções observadoras são o ponto final do diagrama de reatividade e sem eles o fluxo reativo não acontece. As funções render*(), que geram os nossos outputs, são o tipo mais comum de funções observadoras, mas não são o único.\nMuitas vezes queremos usar a reatividade para disparar ações que não estão ligadas à geração de outputs, como o registro de informações em bases de dados, o envio de e-mails ou a atualização de informações nos inputs2. Nesses casos, precisamos utilizar as funções observe() e observeEvent().\nA função observe() monitora os valores e expressões reativas que estão dentro dela e roda seu código quando algum desses valores são modificados. Ao contrário da função reactive(), ela não cria um novo valor reativo. O código atribuído a ela é o ponto chegada de um fluxo reativo, isto é, a ação que a função observe() executa é o objetivo final do fluxo.\nEssa função é muito utilizada com as funções da família update*(), que servem para atualizar valores de um input na UI. Na segunda caixa de seleção do exemplo a seguir, queremos selecionar apenas os filmes do diretor ou diretora que selecionamos na primeira caixa. Veja que usamos o texto Carregando... como um placeholder para o segundo selectInput().\nlibrary(shiny)\n\n# install.packages(\"dados\")\ncarros &lt;- dados::comuns\n\nui &lt;- fluidPage(\n  selectInput(\n    \"marca\",\n    \"Selecione uma marca\",\n    choices = sort(unique(carros$marca))\n  ),\n  selectInput(\n    \"modelo\",\n    \"Selecione um modelo\",\n    choices = \"Carregando...\"\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  observe({\n    opcoes &lt;- carros |&gt; \n      dplyr::filter(marca == input$marca) |&gt; \n      dplyr::pull(modelo)\n    updateSelectInput(\n      session,\n      inputId = \"modelo\",\n      choices = opcoes\n    )\n  })\n}\n\nshiny::shinyApp(ui, server)\nNa função server, atualizamos as escolhas da segunda caixa de seleção com a função updateSelectInput(). Veja que, como essa função está dentro de um observe, esse código será rodado novamente sempre que o valor de input$direcao mudar.\nNesse exemplo, o objetivo final do fluxo reativo é atualizar as opções da segunda caixa de seleção sempre que alterarmos o valor da primeira. Repare que não há nenhum output. A reatividade só funciona nesse caso porque a função observe() é uma função observadora.\nA função observeEvent() funciona assim como a observe(), mas ela escuta apenas um valor ou expressão reativa, que é definido em seu primeiro argumento, assim como na função eventReactive(). Ela é muito utiliza para disparar ações, como gravar informações em uma base de dados, a partir de botões.\nNo exemplo a seguir, queremos salvar o e-mail de uma pessoa quando ela clicar no botão “Enviar dados”. A função observeEvent() roda o código definido dentro dela quando o botão é clicado, salvando o e-mail em um arquivo de texto.\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  textInput(\"email\", \"Informe seu e-mail\"),\n  actionButton(\"enviar\", \"Enviar dados\")\n)\n\nserver &lt;- function(input, output, session) {\n  \n  observeEvent(input$enviar, {\n    write(input$email, \"emails.txt\", append = TRUE)\n  })\n}\nAs funções observe() e observeEvent() aumentam bastante o leque de opções dos nossos aplicativos. Agora conseguimos criar fluxos reativos que não estão associados necessariamente a um output.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Reatividade: mais peças</span>"
    ]
  },
  {
    "objectID": "reatividade-mais-pecas.html#mais-valores-reativos",
    "href": "reatividade-mais-pecas.html#mais-valores-reativos",
    "title": "7  Reatividade: mais peças",
    "section": "7.2 Mais valores reativos",
    "text": "7.2 Mais valores reativos\nJá discutimos anteriormente que os valores reativos são o início do diagrama de reatividade e que os valores da lista input são o principal tipo de valor reativo em um shiny app.\nEm alguns casos, no entanto, vamos precisar de valores reativos que não são inputs, isto é, não estão associados a ações vindas da UI. Esses valores reativos servirão para contralar a reatividade, disparando-a diretamente a partir do servidor. Como não podemos escrever na lista input, precisamos de uma nova peça para criar esses valores: a função reactiveVal().\nPara criar um valor reativo utilizando essa função, utilizamos a seguinte notação:\n\nvr &lt;- reactiveVal(1)\n\nIsso criará um valor reativo chamado vr que possui, inicialmente, o valor 1.\nPara acessar esse valor, fazemos:\n\nvr()\n\nEsse código retornará o valor 1. Repare que é a mesma notação das expressões reativas, criadas com as funções reactive() ou eventReactive().\nPara alterar o valor de um valor reativo, fazemos:\n\nvr(2)\n\nDessa maneira, o vr passa a guardar o valor 2 e, se rodarmos vr() novamente, receberemos o valor 2 dentro de 1. Além disso, sempre que alteramos o valor de um valor reativo, ele vai disparar reatividade. Isso quer dizer que todos as expressões reativas e funções observadoras que dependerem de vr() serão invalidadas e seus códigos rodados novamente.\nTambém podemos usar a função reactiveValues() para criar valores reativos. Com ela, podemos criar uma lista de valores, em vez de apenas um. A notação nesse caso será a seguinte:\n\n# Para criar os valores reativos\nrv &lt;- reactiveValues(a = 1, b = 2)\n\n# Para acessar os valores\nrv$a\nrv$b\n\n# Para atualizar os valores\nrv$a &lt;- 3\nrv$b &lt;- 4\n\nUm caso em que criar valores reativos no servidor se torna útil aparece quando precisamos modificar a base de dados que alimenta os outputs a partir de alguma ação na UI, como a possibilidade de adicionar ou remover uma linha. Veja o exemplo abaixo.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Exemplo reactValues\"),\n  sidebarLayout(\n    sidebarPanel(\n      h3(\"Remover uma linha\"),\n      numericInput(\n        \"linha\",\n        label = \"Escolha uma linha para remover\",\n        value = 1,\n        min = 1,\n        max = nrow(mtcars)\n      ),\n      actionButton(\"remover\", label = \"Clique para remover\"),\n    ),\n    mainPanel(\n      reactable::reactableOutput(\"tabela\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n\n  rv_mtcars &lt;- reactiveVal(value = mtcars)\n\n  observeEvent(input$remover, {\n    \n    nova_mtcars &lt;- rv_mtcars() |&gt;\n      dplyr::slice(-input$linha)\n    \n    rv_mtcars(nova_mtcars)\n    \n  })\n\n  output$tabela &lt;- reactable::renderReactable({\n    rv_mtcars() |&gt;\n      reactable::reactable(width = 600)\n  })\n\n}\n\nshinyApp(ui, server)\n\nRepare que a base mtcars foi transformada em um valor reativo chamado rv_mtcars. Assim, sempre que a instrução de remover uma linha é feita na UI a partir do botão remover, o rv_mtcars é atualizado com a base sem a linha escolhida. Como o output tabela depende de rv_mtcars, a tabela na tela também é atualizada3.\nComo desafio, tente refazer esse app sem a criar valores reativos no servidor, utilizando expressões reativos, por exemplo. É possível?",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Reatividade: mais peças</span>"
    ]
  },
  {
    "objectID": "reatividade-mais-pecas.html#sec-validacao",
    "href": "reatividade-mais-pecas.html#sec-validacao",
    "title": "7  Reatividade: mais peças",
    "section": "7.3 Validação",
    "text": "7.3 Validação\nO pacote shiny possui algumas funções que nos ajudam a validar valores reativos antes de rodarmos um código que gera um output. Na UI, isso impede que mensagens de erros internas do R apareçam na tela e nos possibilita enviar mensagens quando quem está usando o app faz algo que não deveria. Internamente, nos permite controlar melhor a reatividade e deixa o app mais eficiente.\nNas próximas seções falaremos da função req() e da função validate().\n\n7.3.1 A função req()\nA função req(x) retorna um erro silencioso caso x seja inválido. O erro é silencioso pois não possui mensagem, então nada aparecerá na tela. Aqui, inválido indica qualquer um dos seguintes valores:\n\nFALSE\nNULL\n\"\", uma string vazia\nUm vetor vazio (e.g., character(0))\nUm vetor que contenha apenas NA\nUm vetor lógico que contenha apenas FALSE ou NA\nUm objeto com classe try-error\nUm valor reativo que represente um actionButton() que ainda não foi clicado\n\nVocê também pode testar diretamente se um valor é inválido utilizando a função isTruthy.\nO erro silencioso é passado adiante, até o observer que está sendo recalculado. Se você utilizar a opção cancelOutput = TRUE e estiver recalculando uma função render, o output associado será mantido no estado atual, isto é, não será substituído por uma tela vazia caso o valor testado seja inválido.\nVeja um exemplo de utilização da função req(). No código abaixo, a infoBox só será criada se o valor reativo input$filme tiver um valor válido (no caso, uma string não vazia). Caso o valor seja inválido, a infoBox não será mostrada no app. Nenhuma mensagem de erro ou aviso será retornado.\n\n# server\noutput$orcamento &lt;- renderInfoBox({\n  \n  req(input$filme)\n  \n  orcamento &lt;- imdb %&gt;% \n    filter(titulo == input$filme) %&gt;% \n    pull(orcamento)\n  \n  infoBox(\n    title = \"Orçamento\",\n    value = orcamento\n  )\n  \n})\n\n\n\n7.3.2 Mensagens de erro personalizadas\nEm vez de gerar um erro silencioso, não mostrando nada na tela, podemos criar uma mensagem de erro customizada quando um valor for inválido ou não cumprir algum requisito. Para isso, utilizamos a função validate(). Essa função deve receber um dos três seguintes valores:\n\nNULL, se o valor for válido;\nFALSE, se você quiser retornar um erro silencioso, assim como na função req();\numa string, que será transformada em uma mensagem de erro e mostrada na tela4.\n\nEssa função é muito utilizada com a função need(), que recebe um teste lógico e uma string. Se o teste for verdadeiro, ela retorna NULL e, se for falso, retorna a string.\nNo exemplo abaixo, se o input$filme não for válido, além de o aplicativo não mostrar a infoBox, a mensagem “Nenhum filme selecionado.” é mostrada na tela explicando o porquê. No código, utilizamos isTruthy(input$filme) para testar se input$filme é válido.\n\n#server\noutput$orcamento &lt;- renderInfoBox({\n  validate(\n    need(isTruthy(input$filme), message = \"Nenhum filme selecionado.\")\n  )\n  orcamento &lt;- imdb %&gt;% filter(titulo == input$filme) %&gt;% pull(orcamento)\n  infoBox(\n    title = \"Orçamento\",\n    value = orcamento\n  )\n})",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Reatividade: mais peças</span>"
    ]
  },
  {
    "objectID": "reatividade-mais-pecas.html#exercícios",
    "href": "reatividade-mais-pecas.html#exercícios",
    "title": "7  Reatividade: mais peças",
    "section": "7.4 Exercícios",
    "text": "7.4 Exercícios\n1 - Por que precisamos das funções observe() e observeEvent()? Qual a diferença entre elas?\n\n2 - Para que serve a função reactiveVal()?\n\n3 - Qual a diferença entre as funções reactiveVal() e reactiveValues()?\n\n4 - Quais valores retornam FALSE na função isTruth()?\n\n5 - Para que serve a função req()?\n\n6 - Utilizando a base dados::dados_gapminder, construa um app que tenha um filtro de continente e outro de pais. Escolhido um continente, apenas países do continente escolhido devem permanecer no filtro de pais. Como output, seu app deve apresentar as séries de populacao, expectativa_de_vida e pib_per_capita ao longo dos anos disponíveis.\n\n7 - Faça um app que contenha um formulário de cadastro com os campos “nome”, “e-mail”, “idade” e “cidade” e um botão de salvar dados que faça o app salvar as informações em uma planilha no computador. O app também deve mostrar a tabela mais atualizada de pessoas cadastradas.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Reatividade: mais peças</span>"
    ]
  },
  {
    "objectID": "reatividade-mais-pecas.html#footnotes",
    "href": "reatividade-mais-pecas.html#footnotes",
    "title": "7  Reatividade: mais peças",
    "section": "",
    "text": "Isto é, todos os caminhos de um diagrama de reatividade devem começar com um valore reativo e terminar com uma função observadora↩︎\nSem a necessidade de recriá-los do zero com uiOutput() e renderUI().↩︎\nSe você não conhece o pacote reactable, falaremos dele na Seção Seção 8.1.1.↩︎\nEm cor cinza, não o vermelho padrão das mensagens de erro.↩︎",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Reatividade: mais peças</span>"
    ]
  },
  {
    "objectID": "htmlwidgets.html",
    "href": "htmlwidgets.html",
    "title": "8  htmlwidgets",
    "section": "",
    "text": "8.1 Tabelas\nFalaremos a seguir como utilizar as bibliotecas React Table e DT para construir tabelas interativas em seu Shiny app.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>htmlwidgets</span>"
    ]
  },
  {
    "objectID": "htmlwidgets.html#tabelas",
    "href": "htmlwidgets.html#tabelas",
    "title": "8  htmlwidgets",
    "section": "",
    "text": "8.1.1 React Table\nO pacote reactable nos permite criar tabelas interativas baseadas na biblioteca React Table.\nPrimeiro precisamos instalar o pacote:\n\ninstall.packages(\"reactable\")\n\nPara transformar qualquer data.frame em uma React Table, basta usar a função reactable():\n\nmtcars |&gt; \n  reactable::reactable()\n\n\n\n\n\nRepare que a tabela é automaticamente paginada e, como ela possui muitas colunas, uma barra de rolagem horizontal é criada. Além disso, se você clicar no nome das colunas, as linhas serão ordenadas pelos seus valores.\nA função reactable() possui diversos argumentos para customizar a tabela. No exemplo abaixo, deixamos a tabela listrada e incluídos um campo de busca global.\n\nmtcars |&gt; \n  reactable::reactable(\n    striped = TRUE,\n    searchable = TRUE\n  )\n\n\n\n\n\nPara criar uma reactable no nosso app, precisaremos das funções reactable::reactableOutput() e reactable::renderReactable().\n\n# ui\nreactable::reactableOutput(\"tabela\")\n\n# server\noutput$tabela &lt;- reactable::renderReactable({\n  reactable::reactable(mtcars)\n})\n\n\nUm recurso muito útil dentro do Shiny é a possibilidade de selecionar linhas. Fazemos isso utilizando o argumento selection, que pode receber os valores single (se apenas uma linha poderá ser selecionada) ou multiple (se várias linhas poderão ser selecionadas).\n\nmtcars |&gt; \n  reactable::reactable(\n    selection = \"multiple\"\n  )\n\n\n\n\n\nPara acessar quais linhas estão selecionadas, basta utilizar a função getReactableState(\"outputId\", name = \"selected\") dentro de um contexto reativo. Ela devolverá um vetor com o índice das linhas selecionadas.\nA partir dessa função, também podemos recuperar o número da página, o número de linhas da página e o número de páginas da tabela. Basta trocar o parâmetro name respectivamente por \"page\", \"pageSize\" ou \"pages\".\nPara saber mais sobre reactable, clique aqui para acessar o tutorial completo do pacote.\n\n\n8.1.2 DT\nO pacote DT embrulha a biblioteca JavaScript DataTables e é uma alternativa ao reactable para a criação de tabelas interativas. Embora seja mais burocrático na customização, essa biblioteca possui um recurso muito útil para a aplicativos Shiny: a edição de tabelas.\nAntes de mais nada, instale o pacote DT:\n\ninstall.packages(\"DT\")\n\nPara criar uma tabela DT, basta utilizar a função DT::datatable() em qualquer data.frame.\n\nmtcars |&gt; \n  DT::datatable()\n\n\n\n\n\nVeja que assim como a React Table, a tabela já é paginada automaticamente. As colunas também podem ser ordenadas clicando em seus nomes. Além disso, o campo de busca global é criado por padrão.\n\nPara criar uma DT dentro do Shiny, utilizamos as funções DT::dataTableOutput() e DT::renderDataTable().\n\n# ui\nDT::dataTableOutput(\"tabela\")\n\n# server\noutput$tabela &lt;- DT::renderDataTable({\n  DT::datatable(mtcars)\n})\n\nPara criar uma tabela editável, utilizamos o parâmetro editable = TRUE.\n\n# ui\nDT::dataTableOutput(\"tabela\")\n\n# server\noutput$tabela &lt;- DT::renderDataTable({\n  mtcars |&gt; \n    DT::datatable(editable = TRUE)\n})\n\nPara capturar os valores editados, utilizamos o valor input$outputId_cell_edit, sendo outputId o id dado para a tabela em questão (tabela no exemplo anterior). Esse valor é criado automaticamente na lista input quando um dado é editado na tabela.\nPara que os dados editados realmente passem a fazer parte da tabela mostrada na tela (não voltem ao estado original caso você troque de página, por exemplo), você precisa, dentro do servidor, explicitamente substituir esses novos valores na tabela.\nAbaixo, apresentamos um exemplo de como fazer isso.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  DT::dataTableOutput(\"tabela\")\n)\n\n# server\n\nserver &lt;- function(input, output, server) {\n  \n  tabela_atual &lt;- reactiveVal(mtcars)\n  \n  output$tabela &lt;- DT::renderDataTable({\n    mtcars |&gt;\n      DT::datatable(editable = TRUE)\n  })\n  \n  # Criamos uma forma de nos comunicarmos\n  # com a tabela criada na tela\n  proxy &lt;- DT::dataTableProxy(\"tabela\")\n  \n  observeEvent(input$tabela_cell_edit, {\n    \n    # Criamos um objeto com a tabela atualizada\n    # a partir dos dados alterados na tela\n    tab_atualizada &lt;- DT::editData(\n      tabela_atual(),\n      input$tabela_cell_edit\n    )\n    \n    # O valor reativo que guarda a tabela\n    # atual recebe a tabela atualizada\n    tabela_atual(tab_atualizada)\n    \n    # Os dados da tabela na tela são substituídos\n    DT::replaceData(\n      proxy,\n      tab_atualizada\n    )\n    \n  })\n}\n\nshinyApp(ui, server)\n\nO objeto proxy é utilizado para se comunicar com a tabela, de tal forma que os novos valores possam ser substituídos diretamente na tabela que já está dentro do HTML mostrado na tela sem precisar recriá-la. Essa tarefa é feita pela função DT::replaceData(). A tabela atualizada é criada pela função DT::editData(), que recebe a tabela atual e as alterações, salvas dentro do valor reativo input$tabela_cell_edit.\nRepare que, para guardarmos sempre qual é a tabela atual, criamos um valor reativo que é atualizado sempre que uma mudança é feita na tabela.\nAlém do input$outputId_cell_edit, o pacote DT cria outros valores reativos na lista input que podem ser utilizados para gerar interatividade:\n\ninput$outputId_rows_selected: para capturar linhas selecionadas\ninput$outputId_columns_selected: para capturar colunas selecionadas\ninput$outputId_cell_clicked: para capturar o valor, a linha e a coluna da célula clicada\ninput$tableId_search: para capturar a string atualmente no campo de busca global da tabela\n\nSaiba mais sobre DT acessando a documentação do pacote.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>htmlwidgets</span>"
    ]
  },
  {
    "objectID": "htmlwidgets.html#gráficos",
    "href": "htmlwidgets.html#gráficos",
    "title": "8  htmlwidgets",
    "section": "8.2 Gráficos",
    "text": "8.2 Gráficos\nQuando estamos construindo páginas ou aplicações Web (ou apresentações de slides em HTML), além de gráficos em formato de imagem, podemos construir visualizações utilizando bibliotecas JavaScript, que permitem animações e possuem diversas funcionalidades interativas, como tooltips, filtros, zoom e drilldrown.\nNa Seção 6.2, falamos como colocar gráficos estáticos no Shiny utilizando o pacote ggplot2. Nesta seção, falaremos das bibliotecas JavaScript plotly, ECharts e Highcharts para criação de gráficos interativos e de como utilizá-las dentro do Shiny.\n\n8.2.1 plotly\nA biblioteca plotly, além de permitir a criação de gráficos interativos, possibilita fazermos isso diretamente de um gráfico feito em ggplot2. Para utilizar essa biblioteca a partir do R, utilizamos o pacote plotly.\n\ninstall.packages(\"plotly\")\n\nPara transformar um ggplot em plotly, usamos a função plotly::ggplotly().\n\nlibrary(ggplot2)\nlibrary(plotly)\n\np &lt;- mtcars |&gt; \n  ggplot(aes(x = wt, y = mpg)) +\n  geom_point()\n\nggplotly(p)\n\n\n\n\n\nVeja que esse gráfico possui um visual muito parecido com o do ggplot e, além disso,\n\nmostra uma tooltip quando passamos o cursor em cima de um ponto\npermite selecionar uma área do gráfico para dar zoom;\ne possui uma barra de ferramentas que nos permite aumentar e diminuir o zoom, focar em regiões do gráfico e baixar o gráfico como uma imagem estática.\n\nNo exemplo a seguir, além das funcionalidades acima, também podemos clicar na legenda para adicionar ou remover grupos de pontos do gráfico.\n\nlibrary(ggplot2)\nlibrary(plotly)\n\np &lt;- mtcars |&gt; \n  ggplot(aes(x = wt, y = mpg, color = as.character(cyl))) +\n  geom_point()\n\nggplotly(p)\n\n\n\n\n\nPara controlar o que aparece na tooltip, podemos usar o parâmetro tooltip. Veja que adicionamos o modelo do carro e passamos por meio do aes text. O tema escolhido para o ggplot é, na medida do possível, respeitado pelo plotly.\n\nlibrary(ggplot2)\nlibrary(plotly)\n\np &lt;- mtcars |&gt; \n  tibble::rownames_to_column() |&gt; \n  ggplot(aes(x = wt, y = mpg, color = as.character(cyl), text = rowname)) +\n  geom_point() +\n  theme_minimal()\n\nggplotly(p, tooltip = c(\"x\", \"y\", \"text\"))\n\n\n\n\n\nTambém podemos construir um gráfico diretamente pelo plotly, mas isso exige aprendermos a sintaxe das suas funções e as opções disponíveis da biblioteca JS plotly.\n\nplot_ly(mtcars, x = ~wt, y = ~mpg, type = \"scatter\", mode = \"markers\")\n\n\n\n\n\nPara aprender mais sobre como fazer gráficos diretamente no plotly, confira o tutorial oficial da biblioteca.\nPara adicionar um plotly no Shiny, criado a partir da função ggplotly() ou da função plot_ly(), utilizamos o par de funções plotly::plotlyOutput() e plotly::renderPlotly().\nRode o app abaixo para ver um exemplo.\n\nlibrary(shiny)\nlibrary(ggplot2)\n\nvars &lt;- names(mtcars)\n\nui &lt;- fluidPage(\n  titlePanel(\"Plotly\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        \"x\",\n        \"Eixo x\",\n        choices = vars\n      ),\n      selectInput(\n        \"y\",\n        \"Eixo y\",\n        choices = vars,\n        selected = vars[2]\n      )\n    ),\n    mainPanel(\n      plotly::plotlyOutput(\"grafico\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  output$grafico &lt;- plotly::renderPlotly({\n    p &lt;- mtcars |&gt;\n      tibble::rownames_to_column() |&gt;\n      ggplot(aes(\n        x = .data[[input$x]],\n        y = .data[[input$y]],\n        text = rowname\n      )) +\n      geom_point() +\n      theme_minimal()\n    \n    plotly::ggplotly(p)\n  })\n}\n\nshinyApp(ui, server)\n\nEventos no plotly podem ser acessados a partir da função plotly::event_data(). Essa função guarda valores reativos com informação de diversas ações realizadas no gráfico, entre elas\n\ncliques realizados no gráfico\nárea do gráfico selecionada\nseleção de itens do gráfico\n\nO nome do evento deve ser passado como parâmetro da função:\n\nevent_data(\"plotly_click\")\nevent_data(\"plotly_selected\")\n\n\nSe você tiver mais de um plotly no app, utilize o argumento source das funções plotly::ggplotly() ou plotly::plot_ly() e da plotly::event_data() para se referenciar a um gráfico específico.\n\n# criando o plotly\np &lt;- ggplot(mtcars, aes(x = \"wt\", y = \"mpg\")) +\n  geom_point()\n\nplotly::ggplotly(p, source = \"grafico1\")\n\n# Usando a função event_data()\nplotly::event_data(\"plotly_click\", source = \"grafico1\")\n\nPara saber mais veja o help(event_data) ou leia a documentação oficial.\n\n\n8.2.2 ECharts\nPara utilizar a biblioteca JavaScript ECharts no R, podemos utilizar o pacote echarts4r.\n\ninstall.packages(\"echarts4r\")\n\nEsse pacote não possui uma função ggecharts, equivalente à ggplotly do pacote plotly, que possibilitaria transformar gráficos feitos em ggplot em gráficos ECharts. Assim, precisamos sempre construir nossos gráficos do zero, usando a sintaxe do echarts4r.\nO echarts4r possui semelhanças e diferenças com relação ao ggplot2. A semelhança mais importante é que construímos gráficos em camadas. A primeira diferença relevante é que essas camadas são unidas pelo %&gt;%/|&gt;, não pelo +. Outra diferença é que não temos uma função aes(), então o mapeamento das variáveis é feito diretamente nos argumentos das funções.\nVamos começar com um exemplo simples: um gráfico de dispersão.\n\nmtcars |&gt; \n  echarts4r::e_charts(x = wt) |&gt; \n  echarts4r::e_scatter(serie = mpg)\n\n\n\n\n\nVeja que o gráfico não possui tooltip por padrão. Precisamos incluí-la na pipeline:\n\nmtcars |&gt; \n  echarts4r::e_charts(x = wt) |&gt; \n  echarts4r::e_scatter(serie = mpg) |&gt; \n  echarts4r::e_tooltip()\n\n\n\n\n\nPara fazermos um gráfico de linhas, usamos a função echarts4r::e_line(). Cada tipo de gráfico será produzido a partir de uma função do tipo echarts4r::e_*(), equivalente às funções geom_*() no ggplot2.\n\nggplot2::txhousing |&gt; \n  dplyr::mutate(year = as.character(year)) |&gt; \n  dplyr::group_by(year) |&gt; \n  dplyr::summarise(sales = mean(sales, na.rm = TRUE)) |&gt; \n  echarts4r::e_charts(x = year) |&gt; \n  echarts4r::e_line(serie = sales) |&gt; \n  echarts4r::e_tooltip()\n\n\n\n\n\nAo contrário do ggplot2, dados agrupados com dplyr::group_by() influenciam a construção do gráfico. No código abaixo, a base sai da função dplyr::summarise() agrupada por city, fazendo com que o ECharts construa uma linha para cada cidade.\n\nggplot2::txhousing |&gt; \n  dplyr::filter(city %in% c(\"Austin\", \"Dallas\", \"Houston\")) |&gt; \n  dplyr::mutate(year = as.character(year)) |&gt; \n  dplyr::group_by(city, year) |&gt; \n  dplyr::summarise(sales = mean(sales, na.rm = TRUE)) |&gt; \n  echarts4r::e_charts(x = year) |&gt; \n  echarts4r::e_line(serie = sales) |&gt; \n  echarts4r::e_tooltip()\n\n`summarise()` has grouped output by 'city'. You can override using the\n`.groups` argument.\n\n\n\n\n\n\nA biblioteca ECharts possui uma extensa variedade de gráficos disponíveis. Você pode visitar a galeria de exemplos para ter uma boa ideia do que é possível fazer. Além disso, clicando nos exemplos, você tem acesso aos códigos JavaScript utilizados para construir os gráficos.\nCom as funções do pacote echarts4r, podemos replicar bastante do que a biblioteca ECharts tem para oferecer. Para aprender mais sobre o echarts4r vale a pena olhar os tutoriais na página do pacote.\nEm alguns casos, vamos encontrar gráficos ou elementos dentro de um gráfico que não podem ser construídos a partir dos parâmetros das funções do echarts4r. Nesses casos, vamos precisar olhar a documentação do ECharts e usar parâmetros que não estão definidos nas funções do echarts4r (o que é possível já que a maioria das funções possuem o argumento ...).\nA documentação do ECharts pode assustar à primeira vista, mas logo pegamos o jeito de extrair informação dela. Conforme vamos usando mais bibliotecas JS, seja para fazer gráficos, tabelas, mapas, vamos nos acostumando a ler suas documentações.\nNesse sentido, uma forma de seguir a maneira JavaScript de construir um ECharts é usar a função echarts4r::e_list(). Com ela, definimos os parâmetros do gráfico a partir de listas e conseguimos reproduzir linha a linha um exemplo feito em JS. A seguir, reproduzimos exatamente este exemplo. Veja que a estrutura dos dois códigos é muito parecida.\n\necharts4r::e_chart() |&gt; \n  echarts4r::e_list(list(\n    tooltip = list(trigger = \"item\"),\n    legend = list(top = \"5%\", left = \"center\"),\n    series = list(\n      list(\n        name = \"Access From\",\n        type = \"pie\",\n        radius = c(\"40%\", \"70%\"),\n        avoidLabelOverlap = FALSE,\n        itemStyle = list(\n          borderRadius = 10,\n          borderColor = \"#fff\",\n          borderWidth = 2\n        ),\n        label = list(show = FALSE, position = \"center\"),\n        emphasis = list(\n          label = list(\n            show = TRUE, \n            fontSize = 40,\n            fontWeight = \"bold\"\n          )\n        ),\n        labelLine = list(show = FALSE),\n        data = list(\n          list(value = 1048, name = \"Search Engine\"),\n          list(value = 735, name = \"Direct\"),\n          list(value = 580, name = \"Email\"),\n          list(value = 484, name = \"Union Ads\"),\n          list(value = 300, name = \"Video Ads\")\n        )\n      )\n    )\n  ))\n\n\n\n\n\nPara adicionar um ECharts. no Shiny, utilizamos o par de funções echarts4r::echarts4rOutput() e echarts4r::renderEcharts4r(). Na função echarts4r::renderEcharts4r(), basta passarmos um código que retorne um gráfico ECharts.\nRode o app abaixo para ver um exemplo.\n\nlibrary(shiny)\n\nvars &lt;- names(mtcars)\n\nui &lt;- fluidPage(\n  titlePanel(\"Highcharts\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        \"x\",\n        \"Eixo x\",\n        choices = vars\n      ),\n      selectInput(\n        \"y\",\n        \"Eixo y\",\n        choices = vars,\n        selected = vars[2]\n      )\n    ),\n    mainPanel(\n      echarts4r::echarts4rOutput(\"grafico\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  output$grafico &lt;- echarts4r::renderEcharts4r({\n    mtcars |&gt;\n      echarts4r::e_charts_(x = input$x) |&gt;\n      echarts4r::e_scatter_(serie = input$y)\n  })\n}\n\nshinyApp(ui, server)\n\nO echarts disponibiliza automaticamente diversos eventos na lista input com a seguinte nomenclatura: outputId_eventType. Você deve substituir outputId pelo id passado ao echarts4r::echarts4rOutput e eventType pelo nome do evento. Alguns deles são\n\nclicked_data: retorna os dados de um elemento clicado.\nclicked_serie: retorna a série de um elemento clicado.\nmouseover_data: retorna os dados de um elemento indicado pelo mouse (cursor do mouse em cima do elemento).\n\n\nVeja a lista completa na documentação do pacote.\n\n\n8.2.3 Highcharts\nPara utilizar a biblioteca JavaScript Highcharts no R, podemos utilizar o pacote highcharter.\n\ninstall.packages(\"highcharter\")\n\n\nImportante! A biblioteca Highcharts é gratuita apenas para fins educacionais e não lucrativos (exceto órgãos governamentais). Para outros usos, você pode precisar de uma licença.\n\nO highcharter também não possui uma função tradutora de ggplot, equivalente à ggplotly do pacote plotly. Para criar um Highchart, podemos utilizar a função highcharter::hchart() ou highcharter::highchart().\nA função highcharter::hchart() tem uma sintaxe parecida com a do pacote ggplot2. No entanto, nem todo gráfico será possível ser construído a partir dessa função.\n\nmtcars |&gt; \n  highcharter::hchart(highcharter::hcaes(x = wt, y = mpg), type = \"scatter\")\n\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \n\n\n\n\n\n\nA função highcharter::highchart() segue uma estrutura parecida com a da biblioteca JS, sendo uma opção melhor para construir gráficos mais complexos, pois com essa sintaxe podemos seguir mais facilmente a documentação da Highcharts.\n\nhighcharter::highchart() |&gt; \n  highcharter::hc_add_series(\n    data = highcharter::list_parse2(mtcars[, c(\"wt\", \"mpg\")]),\n    type = \"scatter\"\n  )\n\n\n\n\n\nVeja que, nesse caso, os dados precisaram ser passados em forma de lista. Para isso, utilizamos a função highcharter::list_parse2(), que faz algo equivalente a purrr::map2(mtcars$wt, mtcars$mpg, function(x, y) list(x, y)).\nPara adicionar um Highchart no Shiny, utilizamos o par de funções highcharter::highchartOutput() e highcharter::renderHighchart(). Veja um exemplo a seguir.\n\nlibrary(shiny)\n\nvars &lt;- names(mtcars)\n\nui &lt;- fluidPage(\n  titlePanel(\"Highcharts\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\n        \"x\",\n        \"Eixo x\",\n        choices = vars\n      ),\n      selectInput(\n        \"y\",\n        \"Eixo y\",\n        choices = vars,\n        selected = vars[2]\n      )\n    ),\n    mainPanel(\n      highcharter::highchartOutput(\"grafico\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  output$grafico &lt;- highcharter::renderHighchart({\n    highcharter::highchart() |&gt;\n      highcharter::hc_add_series(\n        data = highcharter::list_parse2(mtcars[, c(input$x, input$y)]),\n        type = \"scatter\"\n      )\n  })\n}\n\nshinyApp(ui, server)\n\nPara acessarmos eventos em um highchart, precisamos adicionar as funções highcharter::hc_add_event_point() ou highcharter::hc_add_event_series() no código que gera os gráficos. Dessa forma, a informação é adicionada à lista input em valores com a seguinte nomenclatura outputId_eventType.\nPor exemplo, para um highchart com outputId = \"grafico\", teremos:\n\ninput$grafico_click\ninput$grafico_mouseOver\n\nPara saber mais, acesse a documentação do pacote.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>htmlwidgets</span>"
    ]
  },
  {
    "objectID": "htmlwidgets.html#mapas",
    "href": "htmlwidgets.html#mapas",
    "title": "8  htmlwidgets",
    "section": "8.3 Mapas",
    "text": "8.3 Mapas\nNesta seção, mostraremos como construir mapas interativos com a biblioteca Leaflet.\n\n8.3.1 Leaflet\nO pacote leaflet nos permite criar mapas interativos baseados na biblioteca JavaScript open-source Leaflet. Para instalar o pacote, rode o código abaixo:\n\ninstall.packages(\"leaflet\")\n\nPara criar um mapa leaflet, utilizamos a função leaflet::leaflet() em conjunto de diversas funções auxiliares que caracterizam o nosso mapa.\n\nleaflet::leaflet() |&gt; \n  leaflet::addTiles() |&gt; \n  leaflet::addMarkers(\n    lng = -46.6623969, \n    lat = -23.5581664, \n    popup = \"Antes da pandemia, a Curso-R morava aqui.\"\n  )\n\n\n\n\n\n\nA função leaflet::addTiles() define o tipo de mapa que será mostrado (o padrão é um mapa de ruas) e a função leaflet::addMarkers() coloca marcadores no mapa. Você também pode associar colunas de uma base aos argumentos lat e lng.\n\nquakes |&gt; \n  dplyr::slice(1:100) |&gt; \n  leaflet::leaflet() |&gt; \n  leaflet::addTiles() |&gt; \n  leaflet::addMarkers(\n    lng = ~long, \n    lat = ~lat\n  )\n\n\n\n\n\n\nUm tutorial de como utilizar o leaflet pode ser encontrado aqui.\nPara colocar um mapa leaflet no nosso app, usamos as funções leaflet::leafletOutput() e leaflet::renderLeaflet(). Rode o app abaixo para ver um exemplo.\n\nlibrary(shiny)\n\nvars &lt;- names(mtcars)\n\nui &lt;- fluidPage(\n  titlePanel(\"Leaflet\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\n        \"mag\",\n        \"Magnitude\",\n        min = min(quakes$mag),\n        max = max(quakes$mag),\n        value = c(5, 6)\n      ),\n    ),\n    mainPanel(\n      leaflet::leafletOutput(\"mapa\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n\n  output$mapa &lt;- leaflet::renderLeaflet({\n\n    quakes |&gt;\n      dplyr::filter(mag &gt;= input$mag[1], mag &lt;= input$mag[2]) |&gt;\n      leaflet::leaflet() |&gt;\n      leaflet::addTiles() |&gt;\n      leaflet::addMarkers(\n        lng = ~long,\n        lat = ~lat\n      )\n\n  })\n\n}\n\nshinyApp(ui, server)\n\nO leaflet envia automaticamente valores provenientes de eventos para a lista input. O seguinte padrão de nome é utilizado: input$outputId_tipoObjeto_nomeEvento.\nSe um mapa com outputId = \"mapa\" tiver um círculo, sempre que o círculo for clicado o valor reativo input$mapa_shape_click será atualizado. Antes do primeiro clique, o valor de input$mapa_shape_click é NULL.\nO leaflet possui os seguintes tipos de objeto (tipoObjeto): marker, shape, geojson e topojson; e os seguintes tipos de eventos (nomeEvento): click, mouseover e mouseout.\nAo realizar uma ação, o valor do input correspondente passa a ser uma lista com os seguintes valores:\n\nlat: a latitude do objeto\nlng: a longitude do objeto\nid: o layerId, se disponível\n\nAlém dos eventos associados a um elemento do mapa, o leaflet também disponibiliza os seguintes eventos\n\ninput$outputId_click: que é atualizado sempre que o mapa base é clicado (o clique não é em um elemento, e sim diretamente no mapa). O valor é uma lista com a latitude e a longitude.\ninput$outputId_bounds: que contém a latitude/longitude dos limites do mapa atualmente visível na tela.\ninput$outputId_zoom: que contém um inteiro indicando o nível do zoom aplicado ao mapa.\ninput$outputId_center: que contém a latitude/longitude do centro do mapa atualmente visível na tela.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>htmlwidgets</span>"
    ]
  },
  {
    "objectID": "htmlwidgets.html#exercícios",
    "href": "htmlwidgets.html#exercícios",
    "title": "8  htmlwidgets",
    "section": "8.4 Exercícios",
    "text": "8.4 Exercícios\n1 - O que são HTML Widgets?\n\n2 - Reproduza este app.\nA base utilizada foi a cetesb. Clique aqui para fazer o download dela.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>htmlwidgets</span>"
    ]
  },
  {
    "objectID": "deploy.html",
    "href": "deploy.html",
    "title": "9  Deploy",
    "section": "",
    "text": "9.1 ShinyApps.io\nO ShinyApps.io é um serviço da RStudio para hospedagem de aplicativos Shiny.\nA conta gratuita permite até 5 aplicações simultâneas e 25 horas mensais de uso (um aplicativo utilizado por 1 hora consome 1 hora do seu plano, 2 aplicativos utilizados simultaneamente por 1 hora consomem 2 horas do seu plano). As contas pagas, além de mais horas, fornecem outras vantagens, como suporte personalizado e autenticação.\nCriada uma conta, você deve conectá-la com o RStudio. Feito isso, você conseguirá fazer o deploy do seu app com alguns cliques. A seguir, mostramos o passo a passo para conectar a sua conta e para fazer o deploy do seu app.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Deploy</span>"
    ]
  },
  {
    "objectID": "deploy.html#sec-deploy-shinyapps",
    "href": "deploy.html#sec-deploy-shinyapps",
    "title": "9  Deploy",
    "section": "",
    "text": "9.1.1 Conectando a sua conta com o RStudio\nPrimeiro, crie uma conta no serviço site shinyapps.io.\nFaço o login na sua conta e, no menu lateral, acesse Account &gt; Tokens.\n\n\n\n\n\n\n\n\n\nNa página de tokens, clique no botão “Add Token” para criar um novo token. No token criado, clique no botão “Show”.\nNa caixa de diálogo aberta, clique no botão “Copy to clipboard” ou clique no botão “Show secret” e copie o código apresentado à esquerda dos botões.\n\n# O código que você deve copiar é similar a este\nrsconnect::setAccountInfo(name = 'sua_conta',\n                          token = 'seu_token',\n                          secret = 'secret_do_token&gt;')\n\nAbra o seu RStudio e acesse Tools &gt; Global Options… &gt; Publishing.\nNa seção “Publishing sections”, clique no botão “Connect”.\n\n\n\n\n\n\n\n\n\nSelecione a opção “ShinyApps.io.” e, na tela seguinte, cole o código copiado no site. Clique em Connect Account e pronto! Seu RStudio estará conectado com a sua conta do ShinyApps.io. Você só precisa fazer isso uma vez por conta ou computador.\n\n\n\n\n\n\n\n\n\n\n\n9.1.2 Subindo o seu app\nCom a conta conectada, para subir um app para o servidor do shinyapps.io basta abrir o script do seu app e clicar no botão “Publish”.\n\n\n\n\n\n\n\n\n\nNa caixa de diálogo, selecione à esquerda o código do seu app e todos os outros arquivos dos quais ele depende, como bases de dados e a pasta www. Em seguida, escolha um nome para o seu aplicativo (esse nome fará parte do link) e clique em “Publish”.\n\n\n\n\n\n\n\n\n\nO processo de deploy pode levar alguns minutos, a depender das dependências do seu app e tamanho dos arquivos que você subir. Quando o processo terminar, você receberá uma URL para acessar o aplicativo.\nCaso o seu app não abra devido a algum erro, você pode acessar os logs de utilização para ter uma dica do que aconteceu. Para isso, no dashboard do ShinyApps.io, acesse Applications &gt; All, no meu lateral. Em seguida, clique no app que você gostaria de investigar. Por fim, acesse a opção “Logs”.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Deploy</span>"
    ]
  },
  {
    "objectID": "deploy.html#autenticação",
    "href": "deploy.html#autenticação",
    "title": "9  Deploy",
    "section": "9.2 Autenticação",
    "text": "9.2 Autenticação\nQuando subimos um app para o shinyapps.io, nosso app passa a ficar disponível em uma URL pública (i.e. qualquer pessoa pode acessar.). O serviço permite autenticação apenas a partir da conta Standard, cujo alto custo mensal pode ser um impedimento.\nNesta seção abordaremos algumas soluções gratuitas1 para criar uma etapa de autenticação no acesso ao seu app. Começaremos com o pacote auth0.\n\n9.2.1 Autenticação com o pacote auth0\nO {auth0} é um pacote desenvolvido pela equipe da Curso-R que permite a implementação de um esquema de autenticação no Shiny usando o serviço Auth0.\nVocê pode instalar o pacote diretamente do CRAN:\n\ninstall.packages(\"auth0\")\n\nA seguir, apresentaremos um passo a passo para criar um app com autenticação usando o auth0. Para mais informações sobre o pacote, clique aqui.\n\nPasso 1: criar uma conta no serviço Auth0\n\nEntre no site auth0.com.\nClique em “Sign Up”.\n\nVocê pode criar uma conta a partir de um nome de usário e senha ou a partir de uma conta do GitHub ou do Google.\n\n\n\n\nPasso 2: crie uma aplicação Auth0\n\nFaça login no no site auth0.com usando a criada no passo 1. Você deverá ver uma página como a abaixo:\n\n\n\n\n\n\n\n\n\n\n\nNo menu à esquerda, clique em Applications &gt; applications e então no botão “Create Application”.\nDê um nome para o seu app.\nSelecione “Regular Web Applications” e clique em “Create”.\n\n\n\nPasso 3: configure a sua aplicação\n\nNa página da sua aplicação, clique em “Settings”.\n\n\n\n\n\n\n\n\n\n\n\nPara usar o auth0 quando estiver rodando o seu app localmente:\n\nAdicione http://localhost:8080 aos campos “Allowed Callback URLs”, “Allowed Logout URLs” e “Allowed Web Origins”.\nVocê pode mudar a porta 8080 para qualquer outra que estiver utilizando.\n\nPara usar o auth0 em seu app hospedado no shinyapps.io:\n\nAdicione a URL completa do seu app (i.e., https://suaconta.shinyapps.io/seu_app) aos campos “Allowed Callback URLs” e “Allowed Logout URLs”.\nAdicione a parte inicial da URL do seu app (i.e., https://suaconta.shinyapps.io) ao campo “Allowed Web Origins”.\n\nPara usar o auth0 em seu app hospedado em um servidor remoto qualquer:\n\nAdicione a URL do seu app aos campos “Allowed Callback URLs”, “Allowed Logout URLs” e “Allowed Web Origins”.\nSe o seu app estiver dentro de uma pasta, isto é, se a URL dele for algo como https://meuservidor.com/meuapp, no campo “Allowed Web Origins” acrescente apenas https://meuservidor.com.\n\nClique em Save Changes.\n\n\n\nPasso 4: configurando o seu Shiny app\n\nCrie um arquivo de configuração para o seu app rodando a função auth0::use_auth0()\n\nEsse arquivo deve estar na mesma pasta que o script do seu app.\nVocê pode escolher o diretório onde o arquivo será criado usando o argumento path. Para mais detalhes, veja a documentão da função.\n\n\n\nauth0::use_auth0()\n\n\nO arquivo _auth0.yml gerado deve conter o seguinte:\n\n\nname: myApp\nremote_url: \"\"\nauth0_config:\n  api_url: !expr paste0(\"https://\", Sys.getenv(\"AUTH0_USER\"), \".auth0.com\")\n  credentials:\n    key: !expr Sys.getenv(\"AUTH0_KEY\")\n    secret: !expr Sys.getenv(\"AUTH0_SECRET\")\n\n\nNa linha remote_url: \"\", coloque a URL do seu app dentro das aspas.\nRode usethis::edit_r_environ(scope = \"project\") e acrescente as seguintes variáveis de ambiente2:\n\n\nAUTH0_USER=...\nAUTH0_KEY=...\nAUTH0_SECRET=...\n\n\nSubstitua os ... pelos valores encontrados na opção Settings da sua aplicação no Auth0, conforme a imagem abaixo:\n\n\n\n\n\n\n\n\n\n\n\nSalve o arquivo e reinicie a sua sessão.\nNo seu aplicativo Shiny, substitua shiny::shinyApp(ui, server)) pelo código abaixo.\n\n\nauth0::shinyAppAuth0(ui, server, options = list(port = 8080))\n\n\nPara rodar localmente, a porta 8080 em options = list(port = 8080) deve ser a mesma definida em http://localhost:8080 no Passo 3.\nPara o RStudio continuar reconhecendo o seu script como um Shiny app, você deve nomeá-lo app.R. Caso contrário, você não terá acesso aos botões “Run App” ou “Publish”.\n\n\n\nPasso 5: rode o seu app\n\nRode o seu app.\n\nSe toda a configuração tiver sido feita corretamente, você será redirecionado para uma página de login antes de ter acesso ao seu app.\n\n\n\n\nPasso 6 (opcional): configurando o acesso\n\nPara desabilitar “Sign ups”:\n\nNo Auth0, acesse pelo menu à esquerda Authentication &gt; Database e clique em “Username-Password-Authentication”.\nHabilite a opção “Disable Sign Ups” se você não quiser que qualquer pessoa consiga se inscrever para usar seu app.\n\nPara criar logins:\n\nNo Auth0, acesse pelo menu à esquerda User Management &gt; Users e clique em “Create User”.\nPreencha os campos “Email” e “Password” e clique em “Create”.",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Deploy</span>"
    ]
  },
  {
    "objectID": "deploy.html#configurando-um-shiny-server",
    "href": "deploy.html#configurando-um-shiny-server",
    "title": "9  Deploy",
    "section": "9.3 Configurando um Shiny Server",
    "text": "9.3 Configurando um Shiny Server",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Deploy</span>"
    ]
  },
  {
    "objectID": "deploy.html#footnotes",
    "href": "deploy.html#footnotes",
    "title": "9  Deploy",
    "section": "",
    "text": "Ou gratuitas até uma certa quantidade de uso.↩︎\nSaiba mais sobre variáveis de ambiente aqui↩︎",
    "crumbs": [
      "Parte 1",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Deploy</span>"
    ]
  },
  {
    "objectID": "modulos.html",
    "href": "modulos.html",
    "title": "10  Módulos",
    "section": "",
    "text": "10.1 O problema\nO código de aplicativos Shiny são naturalmente grandes, pois precisamos construir nele a UI, a lógica reativa do servidor e as visualizações, que muitas vezes dependem de alguma arrumação dos dados.\nConforme o nosso aplicativo cresce, fica cada vez mais difícil manter o código em um único arquivo. Imagine corrigir um errinho simples de digitação no título de um gráfico em um arquivo com mais de 5000 linhas… Cada alteração nesse arquivo vai exigir um CTRL+F ou vários segundos procurando onde precisamos mexer. Além disso, conforme cresce o número de inputs e outputs, garantir que seus IDs são únicos se torna uma tarefa morosa e muito fácil de gerar erros.\nUtilizar módulos resolve exatamente esses problemas. Com eles, vamos dividir o app em pedaços independentes e colocar o código de cada pedaço em arquivos diferentes.\nA nossa experiência com programação em R nos diria para separar o código do app em vários arquivos, transformando partes da UI e do server em objetos ou funções. Assim, bastaria fazer source(\"arquivo_auxiliar.R) para cada arquivo auxiliar no início do código.\nO problema é que essa solução resolve o problema do tamanho do script, mas não o da unicidade dos IDs dos inputs e outputs. Veremos a seguir que módulos são de fato apenas funções, mas com uma característica especial que garante uma maior liberdade na definição dos IDs.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "modulos.html#como-construir-um-módulo",
    "href": "modulos.html#como-construir-um-módulo",
    "title": "10  Módulos",
    "section": "10.2 Como construir um módulo",
    "text": "10.2 Como construir um módulo\nMódulos são um framework para gerenciar a complexidade de aplicativos Shiny muito grandes, que resolve o problema do tamanho dos scripts e da unicidade dos IDs.\nO primeiro conceito que precisamos guardar é que módulos são funções. Então, todas as regras válidas para a criação de uma função valem para a criação de módulos.\nO segundo conceito fala sobre como enxergamos os módulos na prática. Cada módulo será um pedaço do nosso aplicativo, com sua própria UI e seu próprio server. No entanto, um módulo não funciona sozinho, não podemos rodar um módulo como se fosse um app isolado. Cada módulo será encaixado no app, funcionando apenas em conjunto.\nO terceiro conceito diz respeito à unicidade dos IDs. Cada módulo terá o seu próprio ID, sendo que dois módulos não devem ter IDs iguais. Esse ID será utilizado para modificar os IDs dos inputs e outputs dentro do módulo, de tal forma que poderemos ter dois outputId = \"grafico\" se estiverem em módulos diferentes. Dentro de um módulo, continuamos mantendo a unicidade dos inputId e outputId.\nPara modificar os IDs dentro do módulo, utilizamos a função ns(), que é definida no início da UI de todo módulo da seguinte maneira:\n\nns &lt;- NS(id)\n\nA função NS(id) é uma função do Shiny que basicamente cria uma função paste() que cola o valor de id no início de qualquer texto. Nesse caso, id será o ID do módulo. Assim, utilizaremos essa função ns() para embrulhar os inputId e outputId, fazendo que eles tenham como prefixo o id do módulo onde estão.\n\nlibrary(shiny)\nns &lt;- NS(\"id-do-modulo\")\nns(\"grafico\")\n\n[1] \"id-do-modulo-grafico\"\n\n\nCom esses conceitos em mente, o código de um módulo que gera um gráfico de dispersão a partir da escolha das variáveis dos eixos x e y seria:\n\n# Módulo dispersao\n\ndispersao_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    selectInput(\n      inputId = ns(\"variavel_x\"),\n      label = \"Selecione uma variável\",\n      choices = names(mtcars)\n    ),\n    selectInput(\n      inputId = ns(\"variavel_y\"),\n      label = \"Selecione uma variável\",\n      choices = names(mtcars)\n    ),\n    br(),\n    plotOutput(ns(\"grafico\"))\n  )\n}\n\ndispersao_server &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    output$grafico &lt;- renderPlot({\n      plot(x = mtcars[[input$variavel_x]], y = mtcars[[input$variavel_y]])\n    })\n  })\n}\n\nRepare que:\n\nUm módulo é composto por duas funções: nome_do_modulo_ui e nome_do_modulo_server. Essa nomenclatura não é obrigatória, mas é uma boa prática. No exemplo: dispersao_ui e dispersao_server.\nA UI é apenas uma função que recebe um id e devolve código HTML (um objeto com classe shiny.tag.list).\nDefinimos a função ns() no início da UI e a utilizamos para embrulhar todos os inputId e outputId do módulo.\nComo agora estamos construindo a UI dentro de uma função, precisamos embrulhá-la com a função tagList() para retornar todas as tags juntas.\nAssim como a UI, o servidor também é uma função que recebe um id. A diferença é que essa função deve retornar a chamada da função moduleServer().\nA função moduleServer() recebe como primeiro argumento o id e como segundo a nossa função server habitual, isto é, a declaração de uma função com os argumentos input, output e session e que possui a lógica do servidor do módulo.\nNa função server, graças à função moduleServer(), não precisamos nos preocupar com o ns()1, isto é, podemos usar diretamente os IDs que definimos na UI do módulo (input$variavel_x, input$variavel_y, output$grafico).\n\nPara chamar dentro de um app o módulo dispersao construído, basta salvar o código dentro de uma pasta chamada /R e chamar as funções no app.R:\n\n# O arquivo app.R\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  dispersao_ui(\"mod_dispersao\")\n)\n\nserver &lt;- function(input, output, session) {\n  dispersao_server(\"mod_dispersao\")\n}\n\nshinyApp(ui, server)\n\nNo código acima, utilizamos mod_dispersao como ID do módulo. Esse mesmo ID deve ser utilizado na chamada da UI e do server do módulo. Junte os códigos anteriores para ver o módulo dispersão em funcionamento.\nSalvamos o código dos nossos módulos dentro de uma pasta chamada /R pois o Shiny roda automaticamente todos os scripts dentro dessa pasta quando rodamos o app. Se estamos desenvolvendo nosso app dentro de uma pasta chamada projeto/, a estrutura de arquivos deve seguir o esquema a seguir:\nprojeto/\n├── R\n│   └── mod_dispersao.R\n└── app.R\nUma pergunta comum para quem está começando a usar módulos é: quais partes do app devo transformar em um módulo? Não existe uma regra para isso. Tudo depende de como você acha que o código vai ficar melhor organizado. Dito isso, algumas dicas são:\n\nTransformar em módulo uma parte do app que será utilizada várias vezes.\nEm um app com várias páginas (navbarPage, shinydashobard), cada página pode ser um módulo.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "modulos.html#passando-e-retornando-parâmetros-para-um-módulo",
    "href": "modulos.html#passando-e-retornando-parâmetros-para-um-módulo",
    "title": "10  Módulos",
    "section": "10.3 Passando e retornando parâmetros para um módulo",
    "text": "10.3 Passando e retornando parâmetros para um módulo\nComo módulos são apenas funções, podemos passar qualquer número de parâmetros para elas, além do id.\nVamos supor que uma base de dados é carregada dentro do servidor e queremos passá-la para todos os módulos que a utilizam. Faríamos algo como no exemplo abaixo:\n\n# ESSE EXEMPLO NÃO É REPRODUTÍVEL\n\n# server do módulo A\n\nmod_A_server &lt;- function(id, dados) {\n  moduleServer(id, function(input, output, session) {\n    \n    # código do server que precisa dos dados\n    \n  })\n}\n\n# server do módulo B\n\nmod_B_server &lt;- function(id, dados) {\n  moduleServer(id, function(input, output, session) {\n    \n    # código do server que precisa dos dados\n    \n  })\n}\n\n# server do módulo C\n\nmod_C_server &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    \n    # código do server que NÃO precisa dos dados\n    \n  })\n}\n\n# server do app\n\nserver &lt;- function(input, output, session) {\n  \n  dados &lt;- importar_dados() # código para importar os dados\n  \n  mod_A_server(\"mod_A\", dados)\n  mod_B_server(\"mod_B\", dados)\n  mod_C_server(\"mod_C\")\n  \n}\n\nOs parâmetros adicionais do módulo são colocados dentro da função que cria o módulo (a função de fora) e não na função dentro da moduleServer() (a função de dentro).\nVamos supor agora que gostaríamos que um módulo retornasse um valor para a função server do app. Normalmente, esse valor é reativo, o que significa que devemos devolver uma expressão reativa.\nNo exemplo abaixo, simulamos o caso em que o papel do módulo é filtrar uma base.\n\n# Código do módulo\nmod_filtro_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  fluidRow(\n    column(\n      width = 4,\n      selectInput(\n        inputId = ns(\"cyl\"),\n        label = \"Número de cilindros\",\n        choices = sort(unique(mtcars$cyl)),\n        multiple = TRUE,\n        selected = unique(mtcars$cyl)\n      )\n    ),\n    column(\n      width = 4,\n      selectInput(\n        inputId = ns(\"am\"),\n        label = \"Transmissão\",\n        choices = c(\"Automática\" = 0, \"Manual\" = 1),\n        multiple = TRUE,\n        selected = c(0, 1)\n      )\n    ),\n    column(\n      width = 4,\n      selectInput(\n        inputId = ns(\"gear\"),\n        label = \"Número de marchas\",\n        choices = sort(unique(mtcars$gear)),\n        multiple = TRUE,\n        selected = unique(mtcars$gear)\n      )\n    )\n  )\n}\n\nmod_filtro_server &lt;- function(id, dados) {\n  moduleServer(id, function(input, output, session) {\n\n    mtcars_filtrada &lt;- reactive({\n      mtcars |&gt;\n        dplyr::filter(\n          cyl %in% input$cyl,\n          am %in% input$am,\n          gear %in% input$gear,\n        )\n    })\n\n    return(mtcars_filtrada)\n\n  })\n}\n\nPara filtrar a base, criamos uma expressão reativa chamada mtcars_filtrada. Essa expressão é retornada utilizando o código return(mtcars_filtrada). Isso é feito dentro da função server do módulo (a função de dentro).\nVeja agora como ficaria o código de um app que utiliza esse módulo.\n\n# Código do app\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  h2(\"Filtros\"),\n  mod_filtro_ui(\"mod_filtro\"),\n  hr(),\n  tableOutput(\"tabela\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  dados &lt;- mod_filtro_server(\"mod_filtro\")\n\n  output$tabela &lt;- renderTable({\n    dados() |&gt;\n      tibble::rownames_to_column(var = \"modelo\")\n  })\n\n}\n\nshinyApp(ui, server)\n\nSalvamos o valor devolvido pela função mod_filtro_server em um objeto chamado dados. Com esse valor é uma expressão reativa, utilizamos a notação dados() na hora de acessar o seu valor. Tente juntar os códigos acima para ver esse app em funcionamento.\nÉ importante ressaltar que um módulo só pode acessar os valores que estão no server de um app se você explicitamente enviar este valor como parâmetro (como fizemos no primeiro exemplo desta seção). O inverso também vale: o server do app só consegue acessar um valor criado dentro de um módulo se você retorná-lo explicitamente (como fizemos no exemplo anterior).\nPor fim, também é possível passar argumentos para UI de um módulo. Isso é feito de maneira análoga ao que fizemos com o server.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "modulos.html#módulos-dentro-de-módulos",
    "href": "modulos.html#módulos-dentro-de-módulos",
    "title": "10  Módulos",
    "section": "10.4 Módulos dentro de módulos",
    "text": "10.4 Módulos dentro de módulos\nComo módulos são apenas funções, nada nos impede de utilizar um módulo dentro de um outro módulo.\nImagine que estamos construindo um app com várias páginas (com o layout navbarPage() ou shinydashboard, por exemplo). Podemos fazer cada página desse app ser um módulo. Além disso, imagine que um mesmo conjunto de filtros deverá ser colocado em todas as páginas, mas agindo independentemente em cada uma delas. Nesse caso, podemos transformar esses filtros em um módulo e repeti-lo em cada página. Veja o exemplo abaixo:\n\n# ESSE EXEMPLO NÃO É REPRODUTÍVEL\n\n# O código do módulo de uma das páginas\n\nmod_pagina1_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    titlePanel(\"Página 1\"),\n    mod_filtros_ui(ns(\"mod_filtros\")),\n    # ui da página 1\n  )\n}\n\nmod_pagina1_server &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    \n    dados_filtrados &lt;- mod_filtros_server(\"mod_filtros\")\n    \n    # server da página 1\n    \n  })\n}\n\n# O código do módulo dos filtros\n\nmod_filtros_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  tagList(\n    fluidRow(\n      shinydashboard::box(\n        title = \"Filtros\",\n        # UI dos filtros\n      )\n    )\n  )\n}\n\nmod_filtros_server &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n\n    base_filtrada &lt;- reactive({\n      # filtro da base conforme as opções escolhidas na UI\n    })\n\n    return(base_filtrada)\n\n  })\n}\n\nRepare que, como estamos chamando o módulo dos filtros dentro do módulo da “Página 1”, precisamos colocar o id da função mod_filtros_ui dentro de um ns().\nComo exercício, com base no exemplo acima, tente construir um app com algumas páginas, sendo cada uma delas um módulo e com um mesmo conjunto de filtros sendo utilizado dentro delas em forma de módulo.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "modulos.html#exercícios",
    "href": "modulos.html#exercícios",
    "title": "10  Módulos",
    "section": "10.5 Exercícios",
    "text": "10.5 Exercícios\n\nO que são módulos?\n\n\n\nPara que serve a função NS()?\n\n\n\nO que acontece quando colocamos um inputId ou outputId dentro da função ns() em um módulo?\n\n\n\nPara que serve a função moduleServer()?\n\n\n\nPor que salvamos os arquivos com o código dos múdulos dentro de uma pasta /R? Onde essa pasta deve ficar?",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "modulos.html#footnotes",
    "href": "modulos.html#footnotes",
    "title": "10  Módulos",
    "section": "",
    "text": "No entanto, podemos precisar da função ns() se estivermos criando parte da UI dentro do servidor, usando uiOutput() e renderUI(). Nesse caso, basta acrescentar um ns &lt;- NS(id) no começo da função server.↩︎",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Módulos</span>"
    ]
  },
  {
    "objectID": "golem.html",
    "href": "golem.html",
    "title": "11  Golem",
    "section": "",
    "text": "11.1 Motivação\nO destino final de aplicativos Shiny costuma ser um ambiente de produção diferente do ambiente de desenvolvimento. Seja um servidor próprio, uma máquina na nuvem ou o shinyapps.io, o nosso app precisa funcionar nesses ambientes, não apenas na nossa máquina.\nUma vez no ambiente de produção, aplicativos Shiny costumam ficar lá por um bom tempo, gerando a necessidade de manutenção períodica e/ou atualizações. A depender de como o app foi desenvolvido, essas tarefas podem ficar muito mais trabalhosas. Seria interessante, nesse sentido, ter um framework de desenvolvimento que facilitasse a organização e documentação do código e o controle das dependências. É para isso que o Golem foi criado.\nO Golem é um framework para desenvolvimento de aplicativos Shiny prontos para serem colocados em produção. As vantagens são:\nNa próxima seção, abordaremos como usar o pacote golem para obter essas vantagens.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Golem</span>"
    ]
  },
  {
    "objectID": "golem.html#motivação",
    "href": "golem.html#motivação",
    "title": "11  Golem",
    "section": "",
    "text": "padroniza a organização dos scripts e demais arquivos do seu app;\nintegra com pacotes que aceleram o desenvolvimento do código;\nmotiva a documentação do código;\ne facilita o compartilhamento e a reutilização de códigos em outros projetos e com outras pessoas.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Golem</span>"
    ]
  },
  {
    "objectID": "golem.html#como-usar",
    "href": "golem.html#como-usar",
    "title": "11  Golem",
    "section": "11.2 Como usar?",
    "text": "11.2 Como usar?\nAntes de mais nada, precisamos instalar o pacote.\n\ninstall.packages(\"golem\")\n\nPara criar um app dentro do framework Golem, basta rodar o seguinte código:\n\ngolem::create_golem(\"~/Documents/meuapp\")\n\nEsse código vai criar uma pasta chamada meuapp/ dentro de ~/Documents/ (você pode especificar qualquer outra pasta no seu computador). Essa pasta vai conter diversos arquivos que lhe permitirão iniciar o desenvolvimento do seu app dentro do Golem.\nAntes de falarmos dos arquivos dessa pasta, precisamos ter em mente que usar o pacote golem diz muito mais respeito a seguir uma filosofia do que a aprender uma ferramenta. Como os próprios autores descrevem\n\nGolem is an opinionated framework for building production-grade shiny applications.\n\nIsto é, para usar o Golem precisamos construir nosso app de um jeito específico, que os autores consideram ser o melhor. Com relação ao pacote em si, criada a estrutura inicial com a função golem::create_golem(), você poderia continuar o desenvolvimento do app dentro desse framework sem utilizar nenhuma outra função do golem1. O que realmente importa é seguir as seguintes premissas:\n\num aplicativo Golem é construído como um pacote R;\nsempre que conveniente, devemos dividir o nosso app em módulos;\ne devemos documentar as funções que compõem o aplicativo.\n\nAssim, como já falamos de módulos no capítulo anterior, para entender melhor o Golem, precisamos falar um pouco de pacotes.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Golem</span>"
    ]
  },
  {
    "objectID": "golem.html#pacotes",
    "href": "golem.html#pacotes",
    "title": "11  Golem",
    "section": "11.3 Pacotes",
    "text": "11.3 Pacotes\nSe você nunca construiu um pacote de R, recomendamos fortemente a leitura do livro R Packages, em especial os 12 primeiros capítulos. Também recomendamos que treine construindo alguns pacotes simples fora do Shiny/Golem antes de continuar (veja os exercícios deste capítulo). Esse passo atrás é importante para que você saiba diferenciar o que é um pacote de R, o que é o Shiny e o que é o Golem.\nDito isso, para aqueles que por imprudência ou falta de tempo continuarão este texto sem uma base sobre o tema “pacotes”, vamos apresentar os pontos necessários para o entendimento do Golem.\n\n11.3.1 O que é um pacote?\nUm pacote de R é uma forma específica de organizar código, seguindo o protocolo descrito pela R Foundation.\n\nPacotes são a unidade fundamental de código R reprodutível.\n— Wickham & Bryan\n\nUm pacote inclue funções em R, documentação sobre como usá-las, testes e dados de exemplo.\nDe maneira geral, as funções de um pacote tentam resolver bem um problema em específico. O pacote dplyr, por exemplo, possui funções especializadas em manipular bases de dados, já o pacote ggplot2 possui funções para a construção de gráficos.\n\n\n11.3.2 Estrutura básica do pacote\nA seguir, apresentaremos a estrutura básica (arquivos e pastas) de qualquer pacote R.\n\nDESCRIPTION: define o nome, descrição, versão, licença, dependências e outras caracaterísticas do pacote. É um arquivo de metadados.\nLICENSE: especifica os termos de uso e distribuição do seu pacote.\n.Rbuildignore: lista arquivos que não devem ser incluídos ao compilar o pacote R a partir do código-fonte, isto é, arquivos que são úteis apenas no desenvolvimento e não serão enviados para quem instalar o pacote.\nNAMESPACE: este arquivo declara as funções que o pacote exporta (que ficam disponível quando alguém usa library()) e as funções que seu pacote importa de outros pacotes. Ele é criado automaticamente a partir da documentação das funções do pacote. Não devemos editar este arquivo manualmente.\nR/: pasta onde fica o código R das funções do pacote. Essa pasta não deve conter subdiretórios.\n\n\n\n11.3.3 Criando pacotes\nUma maneira fácil de criarmos a estrutura básica de um pacote é usamos a função usethis::create_package(). Você deve passar um caminho como ~/Documents/meupacote e uma nova pasta chamada meupacote será criada dentro da pasta Documents. Essa pasta será tanto um projeto do RStudio quanto um pacote, ambos chamados meupacote.\n\nNão adicione acentos, caracteres especiais e espaços no nome do pacote, assim como nos arquivos que você criar dentro dele.\n\n\nusethis::create_package(\"~/Documents/meupacote\")\n\n\n\n11.3.4 A pasta R/\nDentro de um pacote, a pasta R/ só pode ter scripts R com funções. Guardaremos nela todas as funções que farão parte do nosso pacote, mesmo que elas sejam apenas funções usadas internamente.\nAs funções colocadas dentro dessa pasta nunca devem ser rodadas diretamente. Se você quiser testá-las, deve fazer isso “carregando as funções”, isto é, usando a função devtools::load_all(). Isso fará com que todas as funções dentro da pasta R/ fiquem disponíveis na sua sessão, algo equivalente a fazer library(meupacote), mas com a diferença de também carregar as funções não exportadas.\nPodemos usar usethis::use_r(\"nome-do-arquivo\") para criar um arquivo script R dentro da pasta R/.\n\n\n11.3.5 Dependências\nSem os inúmeros pacotes criados pela comunidade, o R provavelmente já estaria no porão da Ciência de Dados. Por isso, a primeira coisa que escrevemos nos nossos scripts quase sempre é library(algumPacoteLegal). Quando estamos construindo um pacote, é comum querermos utilizar dentro dele outros pacotes que não apenas o R base. Esses pacotes são chamados de dependências.\nAo desenvolver um pacote, a função library() nunca deve ser utilizada2, e todas as funções externas devem ter seus pacotes de origem explicitamente referenciados pelo operador ::. Embora seja chato especificar todos os pacotes, isso traz uma vantagem: as dependências do código estarão sempre atualizadas, pois elas estarão sempre atreladas às próprias funções sendo utilizadas.\nSempre que você utilizar um pacote dentro do pacote que está desenvolvendo, você deve especificá-lo como dependência no arquivo DESCRIPTION. Isso dirá ao R que, ao instalar o seu pacote, ele também precisa instalar todos os pacotes listados como dependência nesse arquivo. Você pode fazer isso facilmente utilizando usethis::use_package(). O código abaixo registra o pacote dplyr como dependência de um pacote sendo construído.\n\nusethis::use_package(\"dplyr\")\n\nSe você está usando um pacote em desenvolvimento a partir de um repositório do GitHub, por exemplo, você pode usar a função usethis::use_dev_package() para adicioná-lo como dependência.\n\nusethis::use_dev_package(\"dplyr\", remote = \"tidyverse/dplyr\")\n\nLeia a documentação dessas funções para mais informações sobre como adicionar dependências ao arquivo DESCRIPTION.\n\n\n11.3.6 Dados\nSe o seu pacote possuir bases de dados, como a dplyr::starwars, ou qualquer outro tipo de objeto do R, como pi ou letters, você deve colocá-los dentro de uma pasta chamada data/, na raiz do projeto, com a extensão .rda3. Isso pode ser feito facilmente a partir da função usethis::use_data().\nAo rodar o código abaixo, por exemplo, vamos criar uma pasta data/ na raiz do pacote, caso ela não exista ainda, e salvar nela o vetor base nomes no arquivo nomes.rda.\n\nnomes &lt;- c(\"Athos\", \"Bruna\", \"Caio\")\nusethis::use_data(nomes)\n\nFazendo isso, quando alguém carregar esse pacote, o objeto nomes ficará disponível para ser utilizado (igual a base starwars fica disponível quando carregamos o dplyr).\n\n\n11.3.7 Documentação de funções\nPara documentar as funções do seu pacote (i.e., gerar aquele documento mostrado quando rodamos ?mean, por exemplo), escrevemos comentários antes da definição da função nos scripts da pasta R/. Fazemos isso usando um tipo de comentários especial, o #', e marcadores que indicam qual parte da documentação estamos escrevendo. A estrutura dos comentários deve ser a seguinte:\n\n#' Título da função\n#'\n#' Descrição da função\n#'\n#' @param a Descrição do primeiro parâmetro.\n#' @param b Descrição do segundo parâmetro.\n#'\n#' @return Descrição do resultado (valor que sai da função).\n#'\n#' @export\nfun &lt;- function(a, b) {\n  a + b\n}\n\nO marcador @export indica que a função ficará disponível quando rodarmos library(meupacote). Se você não quer que a função fique disponível, basta não colocar esse marcador.\nApós escrever a documentação das suas funções dessa maneira, você deve rodar devtools::document() para que ela seja compilada e fique disponível no seu pacote (acessível pelo Help do R). Isso é feito por trás das cortinas pelo pacote roxygen2.\nDica: o RStudio disponibiliza um atalho para criar a estrutura da documentação de uma função. No menu superior, clique em Code -&gt; Insert Roxygen Skeleton.\nPara saber mais sobre documentação de pacotes, leia este capítulo do R Packages.\n\n\n11.3.8 Instalando e compartilhando o seu pacote\nPara verificar se você não feriu alguma regra de desenvolvimento de pacotes R, você pode usar a função devtools::check(). Essa função devolverá um relatório com possíveis problemas que o seu pacote pode ter, como erros de sintaxe, arquivos com extensões não permitidos, dependências não declaradas ou erros de documentação.\nPara instalar o seu pacote localmente durante o desenvolvimento, rode a função devtools::install(). Isso é equivalente a ter o pacote instalado via install.packages().\nO jeito mais fácil de disponibilizar o seu pacote na internet é subi-lo para um repositório público no Github. Dessa maneira, qualquer pessoa pode instalá-lo com a função remotes::install_github().\nPara subir um pacote para o CRAN, o processo é (bem) mais burocrático. Se você quiser saber mais, leia este capítulo do R Packages.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Golem</span>"
    ]
  },
  {
    "objectID": "golem.html#estrutura-de-um-golem-app",
    "href": "golem.html#estrutura-de-um-golem-app",
    "title": "11  Golem",
    "section": "11.4 Estrutura de um Golem app",
    "text": "11.4 Estrutura de um Golem app\nAgora que já sabemos o básico sobre pacotes R, podemos voltar a falar do Golem.\nUma pasta criada pela função golem::create_golem() terá a seguinte estrutura:\n\n#&gt; ├── DESCRIPTION \n#&gt; ├── NAMESPACE \n#&gt; ├── R \n#&gt; │   ├── app_config.R \n#&gt; │   ├── app_server.R \n#&gt; │   ├── app_ui.R \n#&gt; │   └── run_app.R \n#&gt; ├── dev \n#&gt; │   ├── 01_start.R \n#&gt; │   ├── 02_dev.R \n#&gt; │   ├── 03_deploy.R \n#&gt; │   └── run_dev.R \n#&gt; ├── inst \n#&gt; │   ├── app \n#&gt; │   │   └── www \n#&gt; │   │       └── favicon.ico \n#&gt; │   └── golem-config.yml \n#&gt; └── man \n#&gt;     └── run_app.Rd\n\nVeja que ela possui, entre outras coisas, a estrutura básica de um pacote. Vamos descrever cada arquivo mais detalhadamente e discutir a importância dele no contexto do desenvolvimento de um Shiny app:\n\nO arquivo DESCRIPTION: guarda os metadados do pacote. No desenvolvimento de um aplicativo Shiny, ele vai guardar o nome do aplicativo, o que ele faz, as dependências dele, a versão (importante em projetos em produção que recebem atualizações periódicas) e quem contatar quando alguma coisa der errada. Com relação às dependências, isso quer dizer que, para rodar o seu app, o R precisará instalar todos os pacotes listados nesse arquivo.\nO arquivo NAMESPACE: guarda metadados do pacote. Com esse arquivo, podemos carregar apenas funções específicas de um pacote dentro do nosso app4. O Golem faz isso com o pacote shiny nas funções app_ui() e app_server() para não precisarmos colocar shiny:: no início de cada função.\nA pasta R/: guarda as funções do pacote. Como o app será feito dentro de um pacote R, todo o seu código será escrito em funções nessa pasta. O Golem já cria os arquivos para construirmos a UI e o servidor. Os scripts contendo os módulos do aplicativo também devem ser colocados nessa pasta, assim como scripts com funções úteis utilizadas em vários lugares do app.\nO arquivo R/app_config.R: usado para especificar alguns mecanismos do Golem, como ler o arquivo de configuração localizado em inst/golem-config.yml.\nO arquivo R/app_server.R: script com a função app_server(), onde você vai desenvolver o servidor do seu aplicativo.\nO arquivo R/app_ui.R: script com a função app_ui(), onde você vai desenvolver a UI do seu aplicativo, e a função golem_add_external_resources(), utilizada para dizer ao Shiny que a pasta inst/app/www será utilizada como uma fonte de recursos externos, acessada pelo caminho www/nome_do_arquivo5. Além disso, o Golem inclui no HTML do seu app a conexão com todo arquivo CSS e JS que você coloca nessa pasta, então não precisamos fazer isso manualmente.\nO arquivo R/run_app.R: script que contém a função run_app(), utilizada para rodar o app. Ela chama a função shiny::shinyApp(), que inicia o app localmente. A funcão shiny::shinyApp() está dentro da função golem::with_golem_options(), que recebe parâmetros passados para a run_app(). Esses parâmetros podem ser recuperados dentro do app com a função golem::get_golem_options(), deixando a parametrização de um aplicativo Shiny muito mais simples6.\ndev/: pasta com scripts do golem que podem ser utilizados ao longo do desenvolvimento do app. Eles contêm uma lista de funções úteis que ajudam a configurar diversos aspectos do aplicativo. O uso desses scripts é opcional.\nA pasta inst/app/www: local onde adicionaremos os recursos externos do aplicativo (imagens, arquivos CSS, fontes etc) que serão compartilhados com o navegador de quem estiver usando o app. A pasta inst é uma pasta especial no desenvolvimento de pacotes. Ela serve para adicionarmos arquivos que gostaríamos que fossem instalados com o pacote, como arquivos de teste, imagens etc. No contexto do Shiny, ela será utilizada para guardarmos arquivos auxiliares, como a própria pasta app/www, templates .Rmd de relatórios que o app gera, arquivos .md com textos que serão colocados no app, entre outros.\nA pasta man/: contém a documentação do pacote, a ser gerada pelo roxygen2. É muito importante documentarmos todas as funções do nosso app, pois é muito comum que o código precise de ajustes ou atualizações no futuro. Uma breve descrição do que a função espera e o que ela devolve pode ser suficiente para ajudar a pessoa que for mexer no app no futuro (que pode ser você mesma) a esconomizar horas de debug.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Golem</span>"
    ]
  },
  {
    "objectID": "golem.html#principais-funções",
    "href": "golem.html#principais-funções",
    "title": "11  Golem",
    "section": "11.5 Principais funções",
    "text": "11.5 Principais funções\nAlém da função golem::create_golem() que utilizamos para criar o nosso projeto com a estrutura do framework Golem, o pacote golem possui diversas funções úteis para usarmos durante o desenvolvimento do pacote. Vamos listar a seguir algumas delas:\n\ngolem::set_golem_name(): usada para mudar o nome do seu aplicativo. A mudança precisa ser feita tanto no arquivo DESCRIPTION quanto dentro da função app_sys() contida no arquivo R/app_config.R, e essa função realiza essas tarefas.\ngolem::add_module(): cria um arquivo na pasta R/ com o template de um módulo do Shiny. O nome do módulo (utilizado também como nome do arquivo) é passado pelo argumento name.\ngolem::add_css_file() e golem::add_js_file(): cria um arquivo vazio com extensão .css ou .js dentro da pasta inst/app/www do app. O nome desse arquivo pode ser passado pelo argumento name.\ngolem::use_utils_ui(): cria um arquivo chamado golem_utils_ui.R na pasta R/ com diversas funções úteis para serem utilizadas na UI de um Shiny app.\ngolem::use_utils_server(): cria um arquivo chamado golem_utils_server.R na pasta R/ com diversas funções úteis para serem utilizadas no servidor de um Shiny app.\ngolem::add_shinyappsio_file(): cria um arquivo app.R que pode ser utilizado para fazer o deploy do app para o shinyapps.io.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Golem</span>"
    ]
  },
  {
    "objectID": "golem.html#deploy",
    "href": "golem.html#deploy",
    "title": "11  Golem",
    "section": "11.6 Deploy",
    "text": "11.6 Deploy\nNeste capítulo, vamos falar sobre como fazer o deploy do seu app feito em Golem em dois ambientes diferentes: no shinyapps.io e em qualquer máquina ou serviço que rode containers Docker.\n\n11.6.1 Deploy para o shinyapps.io\nPara subir um Shiny app para o shinyapps.io (veja a Seção 9.1 para mais detalhes), precisamos enviar o script primário do nosso app7, normalmente chamado de app.R, junto de todos os arquivos dos quais ele depende (outros scripts, bases de dados, imagens etc). A partir do RStudio, podemos fazer isso com alguns cliques a partir do botão Publish, disponível quando abrimos o arquivo app.R, ou a partir da função rsconnect::deployApp(), que consegue identificar esse script primário caso você não especifique para ela no argumento appPrimaryDoc.\nNo entanto, na estrutura do Golem que vimos até o momento não temos esse arquivo, já que todas as partes do app são construídas dentro de funções na pasta R/. O script run_app.R não pode ser considerado esse script primário pois a chamada da função shiny::shinyApp() está dentro da definição da função run_app(). O que fazer nesse caso?\nA solução é criar um arquivo app.R dentro dessa estrutura. Podemos fazer isso usando a função golem::add_shinyappsio_file(). O arquivo será criado na pasta raiz do seu projeto e poderá ser utilizado como script primário do seu app, isto é, a partir dele você poderá usar o botão Publish. Além do app.R, você deverá subir para o shinyapps.io todos arquivos que constituem o seu app/pacote.\nO arquivo app.R criado vai conter a chamada das seguintes funções:\n\npkgload::load_all()\noptions(\"golem.app.prod\" = TRUE)\nrun_app()\n\n\npkgload::load_all() vai carregar o as funções definidas na pasta R/.\noptions(\"golem.app.prod\" = TRUE) vai definir a variável de sistema golem.app.prod como TRUE. Isso é opcional e pode ser utilizado para criar versões diferentes de homologação ou produção para o seu app.\nrun_app(): roda o seu app, isto é, executa a função shiny::shinyApp().\n\nCom esse arquivo criado, você também poderá utilizar normalmente a função rsconnect::deployApp() para fazer o deploy.\n\n\n11.6.2 Deploy com Docker\nO Docker é um software código aberto para o desenvolvimento e a implantação de aplicações embrulhadas em containers8. Ao colocar o seu app em um container, você garante que o ambiente onde ele ficará hospedado, seja ele qual for, terá todas as dependências que ele precisa para funcionar e estará devidamente configurado para que as pessoas possam acessá-lo por meio de uma URL.\nPara dockerizar um app, precisamos criar um Dockerfile. Esse arquivo conterá todas as instruções necessárias para criar um container possuindo todas as dependências e configurações para hospedar o seu app (incluindo o Shiny Server). O pacote golem possui algumas funções para a criação desse arquivo:\n\ngolem::add_dockerfile(): adiciona um Dockerfile genérico, sem configurações para ambientes específicos.\ngolem::add_dockerfile_shinyproxy(): adiciona um Dockerfile com configurações específicas para o ShinyProxy, uma solução código aberto para o deploy de aplicativos Shiny.\ngolem::add_dockerfile_heroku(): adiciona um Dockerfile com configurações específicas para o Heroku, um serviço para hospedagem de qualquer tipo de aplicação dockerizada.\n\nO Dockerfile será criado na pasta raiz do seu projeto. Para testá-lo localmente, caso você tenha o Docker instalado na sua máquina, basta rodar no Terminal:\ndocker build -t meuApp .\ndocker run -p 8080:80 meuApp\nSe você precisar trocar a configuração padrão do Shiny Server, crie um novo shiny-server.conf na pasta inst/app e insira a seguinte linha no Dockerfile antes da linha EXPOSE 80:\nCOPY ./inst/app/shiny-server.conf /etc/shiny-server/shiny-server.conf\nAlém do ShinyProxy e do Heroku, você também pode subir o seu app dockerizado para plataformas como a AWS e o Google Cloud Engine.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Golem</span>"
    ]
  },
  {
    "objectID": "golem.html#exercícios",
    "href": "golem.html#exercícios",
    "title": "11  Golem",
    "section": "11.7 Exercícios",
    "text": "11.7 Exercícios\n\nQuais são as vantagens de se usar o Golem?\nQual a diferença entre usar Golem e usar apenas módulos?\nPodemos seguir o framework Golem sem usar o pacote golem. Verdadeiro ou falso?\nEm qual arquivo na estrutura de um pacote R definimos as suas dependências?\nConstrua um pacote R que tenha as seguintes funções:\n\n\nsoma(x, y): realiza a soma x + y;\nsubtração(x, y): realiza a subtração x - y;\nmult(x, y): realiza a multiplicação x * y;\ndivisao(x, y): realiza a divisão x / y.\n\n\nConstrua um pacote R que tenha as seguintes funções:\n\n\nread_csvs(arquivos, empilhar = FALSE): ela recebe um vetor com caminhos de arquivos .csv contendo bases de dados e devolve uma lista de tibbles com cada uma das bases se empilhar = FALSE e uma tibble com todas as bases empilhadas se empilhar = TRUE.\nread_excels(arquivos, empilhar = FALSE): a mesma ideia, mas para arquivos .xlsx.\n\n\nAplique o framework Golem no app disponibilizado neste link. Ele utiliza a base de dados Pokemon, que pode ser baixada clicando aqui. Além disso,\n\n\nTransforme o shinydashboard em Bs4Dash: construa ao menos a UI do zero.\nModularize o app (cada página do dashboard deve ser um módulo diferente).\nRefaça os gráficos utilizando alguma biblioteca javascript (plotly, echarts, highcharts etc).\nFaça o deploy do app para o shinyapps.io.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Golem</span>"
    ]
  },
  {
    "objectID": "golem.html#footnotes",
    "href": "golem.html#footnotes",
    "title": "11  Golem",
    "section": "",
    "text": "Na prática, poderíamos construir essa estrutura nós mesmos e usar o framework Golem sem usar o pacote golem.↩︎\nImagine se, ao usarmos uma função de um pacote, ele carregasse um novo pacote na nossa sessão, possivelmente mascarando funções que estamos usando. Isso seria uma péssima prática.↩︎\nArquivos .rda são extremamente estáveis, compactos e podem ser carregados rapidamente pelo R, tornando este formato o principal meio de guardar dados de um pacote.↩︎\nIsso é feito automaticamente pelo roxygen2 a partir da documentação das funções. Não edite esse arquivo na mão.↩︎\nIsto é, você não precisa incluir inst/app/ no caminho do arquivo. Por exemplo, se você quiser colocar a imagem inst/app/www/imagem.png no seu app, basta usar o caminho www/imagem.png.↩︎\nPodemos criar versões diferentes do app que serão executadas a depender dos parâmetros passados na função run_app().↩︎\nO arquivo com a chamada da função shiny::shinyApp() no final.↩︎\nContainers são uma unidade padrão de software que empacota um código e suas dependências de tal forma que a aplicação possa rodar de maneira confiável independentemente do ambiente computacional. Leia mais aqui.↩︎",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Golem</span>"
    ]
  },
  {
    "objectID": "html-css-js.html",
    "href": "html-css-js.html",
    "title": "12  HTML, CSS e JavaScript",
    "section": "",
    "text": "12.1 HTML\nO HTML é uma linguagem de marcação para construir páginas web. Uma linguagem de marcação é apenas um tipo de documento que contem texto simples (como em um bloco de notas) e um conjunto de instruções para formatar (anotar, marcar) parte específicas do conteúdo. Além do HTML, o LaTeX e o (R) Markdown são outros exemplos comuns de linguagem de marcação.\nNas seções a seguir, apresentamos os conceitos básicos da linguagem. São três os objetivos aqui:",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>HTML, CSS e JavaScript</span>"
    ]
  },
  {
    "objectID": "html-css-js.html#html",
    "href": "html-css-js.html#html",
    "title": "12  HTML, CSS e JavaScript",
    "section": "",
    "text": "entender como um documento HTML é estruturado;\nganhar um pouco de vocabulário, isto é, conhecer as principais tags;\ne conhecer a nomenclatura da linguagem, o que vai facilitar bastante quando for preciso pesquisar por algo na internet.\n\n\nTags\nA maior parte do esforço em aprender uma linguagem de marcação está em aprender quais são e como utilizar as instruções de formatação, os seus marcadores. Os marcadores no HTML são as tags. Elas podem ser de abertura ou de fechamento e possuem a seguinte sintaxe:\nTag de abertura: &lt;nome_da_tag&gt;\nTag de fechamento: &lt;/nome_da_tag&gt;\n\n\nElemento HTML\nAs tags no HTML definem os chamados elementos HTML. Um elemento HTML é composto por uma tag de abertura, algum conteúdo e uma tag de fechamento.\n&lt;nome_da_tag&gt; conteúdo &lt;/nome_da_tag&gt;\n\nAlguns elementos podem aparecer corretamente sem a tag de fechamento, mas não conte sempre com isso. Resultados inesperados e erros podem acontecer se você esquecer a tag de fechamento.\n\n\n\nDocumento HTML\nUm documento HTML é um arquivo de texto com extensão .html que possui um código HTML válido dentro. Todo HTML precisa começar com uma declaração de tipo.\n\n&lt;!DOCTYPE html&gt;\n\nEla representa o tipo de documento, o que ajuda os navegadores a mostrar as páginas corretamente. Ela deve aparecer apenas uma vez, no topo da página.\nO código HTML em si começa com a tag &lt;html&gt; e deve terminar com &lt;/html&gt;.\nA parte visível do documento fica entre as tags &lt;body&gt; e &lt;/body&gt;.\n\n&lt;!DOCTYPE html&gt;\n\n&lt;html&gt;\n  &lt;body&gt;\n    O conteúdo da página fica aqui.\n  &lt;/body&gt;\n&lt;/html&gt;\n\nImportante: só pode haver apenas um &lt;body&gt; em um documento HTML.\n\n\nA tag &lt;head&gt;\nA tag &lt;head&gt; cria uma seção de metadados para a nossa página HTML.\nO elemento &lt;title&gt;, por exemplo, pode ser utilizado para definir um título para a página, usado pelo navegador (na aba da página ou na barra de favoritos) e por algoritmos de busca (Google).\n\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Esse é o título da página&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    O conteúdo da página fica aqui.\n  &lt;/body&gt;\n&lt;/html&gt;\n\nVeremos ainda neste capítulo outros metadados que podemos definir na seção &lt;head&gt;.\n\n\nCabeçalhos\nVocê pode construir títulos e subtítulos com as tags &lt;h1&gt; a &lt;h6&gt;.\n\n&lt;h1&gt;Título 1&lt;/h1&gt;\n&lt;h2&gt;Título 2&lt;/h2&gt;\n&lt;h3&gt;Título 3&lt;/h3&gt;\n&lt;h4&gt;Título 4&lt;/h4&gt;\n&lt;h5&gt;Título 5&lt;/h5&gt;\n&lt;h6&gt;Título 6&lt;/h6&gt;\n\n&lt;h1&gt; define o título mais importante, enquanto &lt;h6&gt; o menos importante.\n\nÉ uma boa prática colocar apenas um &lt;h1&gt; por página HTML.\n\n\n\nParágrafos\nParágrafos são definidos pela tag &lt;p&gt;. Eles sempre iniciam em uma nova linha. Os navegadores automaticamente criam um espaço em branco (margem) antes e depois do parágrafo.\n\n&lt;p&gt;\n  Isto é um parágrafo.\n&lt;/p&gt;\n&lt;p&gt;\n  E aqui um outro parágrafo.\n&lt;/p&gt;\n\n\nO HTML não é sensível à caixa das palavras, isto é, &lt;P&gt; e &lt;p&gt; são equivalentes. No entanto, é uma boa prática utilizar sempre a caixa baixa.\n\n\n\nElementos aninhados\nElementos HTML se organizam de maneira hierárquica, isto é, os elementos são aninhados dentro de outros.\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n\n    &lt;h1&gt;Título da página&lt;/h1&gt;\n    &lt;p&gt;Este é o primeiro &lt;b&gt;parágrafo&lt;/b&gt; desta página HTML.&lt;/p&gt;\n\n  &lt;/body&gt;\n&lt;/html&gt;\n\nNo código acima\n\no elemento &lt;body&gt; reside dentro do elemento html;\nos elementos &lt;h1&gt; e &lt;p&gt; residem dentro do elemento body;\ne o elemento &lt;b&gt;, que deixa o texto em negrito, reside dentro do elemento p.\n\n\n\nAtributos\nTodos os elementos HTML podem ter atributos, que provêm informação adicional sobre os elementos.\nAtributos são sempre especificados na tag de abertura. Eles geralmente possuem a seguinte sintaxe nome=\"valor\". Dois argumentos diferentes são separados por um espaço vazio.\n\n&lt;!DOCTYPE html&gt;\n  &lt;html lang=\"pt-BR\"&gt;\n    &lt;body&gt;\n      \"Conteúdo da página\"\n    &lt;/body&gt;\n&lt;/html&gt;\n\nO atributo lang no elemento &lt;html&gt;, por exemplo, declara qual será o idioma utilizado na página1.\n\n\nLinks\nLinks no HTML são chamados de hiperlinks (ou hiperligação). Eles são criados com a tag &lt;a&gt;.\n\n&lt;a href=\"https://curso-r.com\"&gt;\n  Clique aqui para acessar o site da curso-r\n&lt;/a&gt;\n\nVeja que este elemento possui o atributo href, que define o destino do link. O conteúdo deste elemento será o texto visível na tela para ser clicado.\n\n\nComentários\nPodemos adicionar comentários ao nosso código HTML a partir da seguinte sintaxe:\n\nuse &lt;!-- para iniciar o comentário;\nuse --&gt; para encerrar o comentário.\n\n\n&lt;p&gt;Isto é um parágrafo&lt;/p&gt;\n&lt;!-- Isto é um comentário e vai ser ignorado pelo navegador. --&gt;\n&lt;p&gt;Isto é um outro parágrafo&lt;/p&gt;\n\n\n\nElementos vazios\nAlguns elementos HTML não possuem conteúdo e, portanto, não precisam de uma tag de fechamento. Esses elementos são chamados de elementos vazios.\nA tag &lt;br&gt;, que gera uma quebra de linha na página, é um exemplo de elemento vazio.\n\n&lt;p&gt;Parágrafo 1&lt;/p&gt;\n&lt;br&gt;\n&lt;p&gt;Parágrafo 2&lt;/p&gt;\n\nVeja que não precisamos fechar a tag &lt;br&gt; com uma tag &lt;/br&gt;.\n\n\nImagens\nImagens podem ser inseridas em uma página HTML a partir da tag &lt;img&gt;.\n\n&lt;img src = \"caminho_ou_url_da_imagem\" width = \"100px\" height = \"100px\" alt = \"Essa é uma boa descrição da imagem\"&gt;\n\nNo elemento acima:\n\no argumento src é utilizado para especificar o caminho ou URL da imagem\nos argumentos width e height são utilizados para especificar o comprimento e altura da imagem;\nespecificar o comprimento e altura é importante pois o navegador reserva o espaço da imagem na tela, mantendo o layout da página, caso ela demore para ser carregada;\npodemos usar o argumento alt para atribuir uma descrição à imagem, o que é utilizado por leitores de tela para descrever a imagem para pessoas com deficiência visual.\n\n\n\nElementos em bloco e em linha\nOs elementos HTML podem ser divididos em dois tipos: elementos em bloco e elementos em linha.\nElementos em bloco sempre começam em uma nova linha e ocupam todo o comprimento da tela ou todo o comprimento que tiverem à disposição. Os navegadores automaticamente adicionam algum espaço (margem) antes e depois desses elementos.\nElementos em linha não iniciam uma nova linha. Esses elementos só ocupam o comprimento necessário para apresentar seu conteúdo na tela.\n\n\nA tag &lt;div&gt;\nA tag &lt;div&gt; é um elemento em bloco normalmente utilizada como um container para outros elementos HTML. Se você não atribuir nenhum atributo a ela, como comprimento ou altura, ela não gera nenhum efeito na página.\nNormalmente aplicamos a ela atributos que vão definir o estilo de parte ou de todos os elementos que a &lt;div&gt; contém.\n\n&lt;div&gt;\n  &lt;p&gt;Um parágrafo&lt;/p&gt;\n  &lt;a href=\"https://curso-r.com\"&gt;Um link&lt;/a&gt;\n&lt;/div&gt;\n\n\n\nA tag &lt;span&gt;\nA tag &lt;span&gt; é um elemento em linha utilizada como um container para outros elementos HTML. Se você não atribuir nenhum atributo a ela, como comprimento ou altura, ela não gera nenhum efeito na página.\nNormalmente aplicamos a ela atributos que vão definir o estilo de parte ou de todos os elementos que a &lt;div&gt; contém.\n\n&lt;p&gt;\n  Como formatar uma única &lt;span&gt;palavra&lt;/span&gt;?\n&lt;/p&gt;",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>HTML, CSS e JavaScript</span>"
    ]
  },
  {
    "objectID": "html-css-js.html#alemCSS",
    "href": "html-css-js.html#alemCSS",
    "title": "12  HTML, CSS e JavaScript",
    "section": "12.2 CSS",
    "text": "12.2 CSS\nCSS (Cascading Style Sheets) é uma linguagem de folha de estilo utilizada para formatar páginas Web. Com CSS, podemos controlar a cor, fonte, tamanho do texto, espaçamento entre elementos, cores e imagens de fundo, a maneira como os elementos são mostrados na página a depender dos diferentes tamanhos de tela e muito mais!\nO objetivo de uma linguagens de folha de estilo é separar a formatação e a estrutura de um documento, permitindo que sejam construídos isoladamente, mas os unindo a partir de algum tipo de ligação. Veremos adiante como isso se dá no HTML.\n\nA palavra Cascading (cascata) significa que um estilo aplicado a um elemento pai também é aplicado a todos os elementos filhos, o que é uma característica importante devido à hierarquia de elementos do HTML.\n\nA seguir, apresentaremos os conceitos básicos para aplicar CSS a um documento HTML.\n\nRegras CSS\nPara aplicar estilo a um elemento HTML usando CSS, devemos escrever uma regra. A seguir, temos uma regra CSS que define a cor dos parágrafos (o conteúdo dos elementos &lt;p&gt;) como azul e o tamanho da fonte como 12px.\n\np {\n  color: blue;\n  font-size: 12px\n}\n\nNo código:\n\np é chamado de seletor e define quais elementos receberão a regra CSS;\ncolor: blue; e font-size: 12px são chamadas de declarações e definem o estilo a ser aplicado;\ncolor e font-size dentro de cada declaração são chamados de propriedades, isto é, a característica de cada elemento que será alterada;\njá blue e 12px são os valores atribuídos a cada propriedade.\n\nPara aplicar essa regra, podemos inserir esse código em um documento HTML de 3 maneiras:\n\nem linha (inline), dentro do elemento HTML, usando o atributo style;\ninterno (internal), dentro do documento HTML, mas fora dos elementos, usando a tag &lt;style&gt; dentro da seção &lt;head&gt;;\nexterno (external), em um arquivo externo, usando a tag &lt;link&gt; na seção &lt;head&gt; para apontar para um arquivo CSS.\n\nO jeito mais comum de adicionar CSS ao HTML é utilizando um arquivo CSS externo, mas veremos aqui como utilizar as três formas.\n\n\nCSS inline\nO CSS inline é utilizado para aplicar estilo a um único elemento HTML. Fazemos isso usando o atributo style dentro da tag de abertura do elemento.\n\n&lt;p style = \"color: blue;\"&gt; Esse texto terá a cor azul. &lt;/p&gt;\n\nVeja que nesse caso não precisamos declarar um seletor.\n\n\nCSS interno\nUm CSS interno é utilizado para definir estilo para os elementos de uma única página HTML. Ele é definido na seção &lt;head&gt;, dentro de uma tag &lt;style&gt;.\n\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;style&gt;\n        h1 {\n          color: red;\n        }\n        p {\n          color: blue;\n        }\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt; Esse título terá a cor vermelha &lt;/h1&gt;\n    &lt;p&gt; Esse texto terá a cor azul &lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n\n\nCSS externo\nUm arquivo CSS externo é utilizado para definir o estilo de várias páginas HTML. Para associar um arquivo CSS a uma página HTML, usamos a tag &lt;link&gt; na seção &lt;head&gt;.\nA tag &lt;link&gt; é utilizada para estabelecer uma relação entre o arquivo HTML e um arquivo externo. O atributo href recebe o caminho para o arquivo externo (nosso arquivo CSS) e o atributo rel estabele qual o tipo de relação entre os arquivos. No caso de um arquivo CSS, rel deve receber o valor stylesheet.\n\n&lt;!--Arquivo CSS--&gt;\nh1 {\n  color: red;\n}\n\n&lt;!--Arquivo HTML--&gt;&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;link rel=\"stylesheet\" href=\"custom.css\"&gt;\n  &lt;/head&gt;\n&lt;/html&gt;\n\n\n\nCores\nPara alterar cores, utilizamos as propriedades color e background-color. Você pode passar como valor tanto o nome da cor em inglês quanto um código hexadecimal.\n\np {\n  color: white;\n}\n\nh1, h2 {\n  color: #1222bb;\n}\n\nbody {\n  background-color: black;\n}\n\nRepare que você pode selecionar um grupo de elementos separando cada seletor por uma vírgula (h1, h2).\n\n\nTamanho da fonte\nPara alterar o tamanho da fonte, utilizamos a propriedade font-size.\n\np {\n  font-size: 10px;\n}\n\nh1 {\n  font-size: 12pt;\n}\n\n\n\nFontes\nPara alterar a fonte do texto, utilizamos a propriedade font-family.\n\np {\n  font-family: \"Times New Roman\", Times, serif;\n}\n\np {\n  font-family: Arial, Helvetica, sans-serif;\n}\n\nVocê pode especificar mais de uma fonte em uma declaração, o que é útil para garantir que pelo menos uma das fontes especificadas esteja instalada no navegador de quem acessar a página HTML. A preferência é da esquerda para a direita. Na primeira regra do exemplo acima, o navegador tentará aplicar a fonte “Times New Roman” preferencialmente. Se ela não estiver disponível, ela vai aplicar qualquer versão da fonte “Times” e, caso ainda não seja possível, será utilizada qualquer fonte serifada que o navegador usar como padrão. Leia as seções sobre fonte do W3Schools para saber mais.\nPara importar uma fonte do Google fontes, basta utilizar o elemento &lt;link rel = \"stylesheet\"&gt; passando o link da fonte no atributo href.\n\n&lt;head&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://fonts.googleapis.com/css?family=Sofia\"&gt;\n  &lt;style&gt;\n  body {\n    font-family: \"Sofia\", sans-serif;\n  }\n  &lt;/style&gt;\n&lt;/head&gt;\n\nLink para a fonte Sofia: https://fonts.google.com/specimen/Sofia?query=sofia\n\n\nBordas\nPara definir uma borda a um elemento, utilizamos a propriedade border.\n\nh1 {\n  border: 1px solid black;\n}\n\n\nO valor 1px se refere à espessura da borda.\nO valor solid se refere ao estilo da borda.\nO valor black se refere à cor da borda.\n\n\nVocê pode definir uma borda para quase todos os elementos HTML.\n\n\n\nClasses\nElementos HTML possuem um atributo class que pode ser utilizado como seletor em declarações CSS.\n\n&lt;!-- HTML --&gt;\n&lt;p class = \"azul\"&gt;Este parágrafo ficará azul&lt;/p&gt;\n&lt;p&gt;Este parágrafo não ficará azul&lt;/p&gt;\n\n&lt;!-- CSS --&gt;\n.azul {\n  color: blue;\n}\n\nRepare que para usar uma classe como seletor, colocamos um . antes do nome da classe.\n\nElementos HTML podem ter mais de uma classe. Múltiplas classes são separadas por um espaço. Uma mesma classe pode ser utilizada em mais de um elemento HTML.\n\n\n\nIds\nElementos HTML possuem um atributo id que pode ser utilizado como seletor em declarações CSS. Ao contrário das classes, o id deve ser único dentro do documento HTML, isto é, dois elementos HTML não devem ter o mesmo id.\n\n&lt;!-- HTML --&gt;\n&lt;p id = \"paragrafoAzul\"&gt;Este parágrafo ficará azul&lt;/p&gt;\n&lt;p&gt;Este parágrafo não ficará azul&lt;/p&gt;\n\n&lt;!-- CSS --&gt;\n#paragrafoAzul {\n  color: blue;\n}\n\nRepare que para usar um id como seletor, colocamos um # antes do nome do id.\n\n\nEspecificidade\nQuando mais de uma declaração afeta uma mesma propriedade de um elemento HTML, o navegador precisa decidir qual delas será aplicada. Para isso, ele vai se basear nos seguintes valores:\n\nSe o estilo é inline: +1000\nSe o seletor é um id: +100\nSe o seletor é uma classe: +10\nSe o seletor é um elemento: +1\n\nA soma desses valores para uma regra é chamada de especificidade. A regra com maior especificidade será aplicada. Se duas declarações possuirem a mesma especificidade, a última declaração definida no CSS será priorizada.\nA regra a seguir, que seleciona todos os elementos p com classe azul tem especificidade 11, pois o seletor possui uma classe e um elemento.\n\np.azul {\n  color: blue;\n}\n\nJá a seguinte regra tem especificidade de 10, pois só possui um elemento, e seria preterida com relação à anterior.\n\np {\n  color: blue;\n}\n\nAbaixo, temos duas declarações com a mesma especificidade. Nesse caso, a declaração color: yellow; será aplicada por ter sido definido por último.\n\np {\n  color: red;\n}\n\np {\n  color: yellow;\n}\n\nSaiba mais sobre especificidade neste artigo da W3Schools em inglês ou neste artigo em português.\n\n\nBox model\nO box model do CSS é essencialmente uma caixa que envolve todos os elementos HTML. Ele consiste de uma margem, uma borda, padding e o próprio conteúdo do elemento.\nA imagem abaixo ilustra o box model:\n\n\n\n\n\n\n\n\n\n\n\nMargem\nMargens são utilizadas para criar espaço em branco entre elementos HTML. As duas regras CSS a seguir são equivalentes.\n\np {\n  margin: 1px 2px 4px 3px;\n}\n\np {\n  margin-top: 1px;\n  margin-right: 2px;\n  margin-bottom: 4px;\n  margin-left: 3px;\n}\n\n\n\nPadding\nA propriedade padding é utilizada para criar espaço ao redor do conteúdo de um elemento, dentro de qualquer borda definida. As duas regras CSS a seguir são equivalentes.\n\np {\n  padding: 1px 2px 4px 3px;\n}\n\np {\n  padding-top: 1px;\n  padding-right: 2px;\n  padding-bottom: 4px;\n  padding-left: 3px;\n}\n\n\n\nDisplay\nA propriedade display especifica se e como um elemento HTML é exibido na tela.\nTodo elemento HTML tem um valor padrão para essa propriedade. O valor padrão do display para a maioria dos elementos é block (em bloco) ou inline (em linha). Utilizando essa propriedade, podemos fazer uma &lt;div&gt; em linha ou um &lt;img&gt; em bloco.\n\n#divInline {\n  display: inline\n}\n\n#imgBlock {\n  display: block;\n}\n\nTambém é possível atribuir o valor none a essa proprieda, fazendo com que o elemento não seja mostrado na tela. Isso é utilizado com JavaScript para mostrar/esconder elementos.\n\n\nPosicionamento\nA propriedade position define que tipo de posicionamento será utilizado para exibir um elemento na página.\nOs principais valores dessa propriedade são:\n\nstatic — os elementos são renderizados na ordem que eles aparecem no documento HTML (valor padrão);\nrelative — os elementos são posicionados relativamente a sua posição normal, permitindo o ajuste do elemento a partir de offsets (propriedades top, bottom, left e right);\nabsolute — os elementos são posicionados relativamente ao seu primeiro elemento ancestral com position diferente de static;\nfixed — os elementos são posicionados relativamente à janela do navegador.\n\nLeia este artigo para saber mais sobre posicionamento.",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>HTML, CSS e JavaScript</span>"
    ]
  },
  {
    "objectID": "html-css-js.html#javascript",
    "href": "html-css-js.html#javascript",
    "title": "12  HTML, CSS e JavaScript",
    "section": "12.3 JavaScript",
    "text": "12.3 JavaScript\nO JavaScript (JS) é uma linguagem de programação criada para a Web. Ele foi criado em apenas 10 dias, em 1995, por uma única pessoa, Brendan Eich. Ele foi inicialmente chamado LiveScript, mas como a linguagem Java era popular na época, o nome mudou para JavaScript, embora as duas linguagens não tenham nenhuma relação uma com a outra.\nO papel do JavaScript é possibilitar interatividade em páginas Web. Enquanto o HTML e o CSS apenas ditam como esse conteúdo será apresentado na tela, códigos JavaScript geram comportamentos disparados por ações da pessoa acessando a página.\nO código JS é colocado junto ao HTML e interpretado pelo navegador. Todo navegador moderno possui um interpretador de JavaScript: você pode testar isso acessando as “Ferramentas de desenvolvedor” do seu navegador e clicando na aba “Console”. O terminal apresentado será um interpretador JavaScript.\n\n\n\n\n\nInterpretador JavaScript no Google Chrome.\n\n\n\n\nNesta seção, não faremos uma introdução formal ao JavaScript, pois qualquer tentativa seria incompleta ou muito extensa para o escopo desse livro. Além disso, existe bastante conteúdo introdutório e gratuito sobre JavaScript disponível na internet. O que abordaremos aqui será, dado algum conhecimento prévio da linguagem, como utilizar o JavaScript dentro do Shiny. Começaremos mostrando como inserir um código feito em JS no seu Shiny app e, em seguida, como acessar valores dos inputs do app dentro de um código JavaScript.\n\n12.3.1 Inserindo JavaScript em seu app\nPara inserir um código JavaScript em um arquivo HTML, utilizamos o elemento &lt;script&gt;&lt;/script&gt;. Podemos escrever diretamente o código JavaScript dentro desse elemento ou ler o código de um arquivo externo definido pelo atributo src. Os dois exemplos abaixo são equivalentes e mudam para vermelho a cor do primeiro parágrafo quando clicamos no botão.\n\n# Definindo o código diretamente no HTML\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n    &lt;p id = \"alvo\"&gt;\n      Parágrafo 1\n    &lt;/p&gt;\n    &lt;p&gt;\n      Parágrafo 2\n    &lt;/p&gt;\n    &lt;button onClick = \"deixarVermelho()\"&gt;\n      Deixar vermelho\n    &lt;/button&gt;\n    &lt;script&gt;\n      deixarVermelho = function() {\n        document.getElementById(\"alvo\").style = \"color: red\";\n      }\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n  \n# Importando o código de um arquivo JS\n\n# HTML\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;body&gt;\n    &lt;p id = \"alvo\"&gt;\n      Parágrafo 1\n    &lt;/p&gt;\n    &lt;p&gt;\n      Parágrafo 2\n    &lt;/p&gt;\n    &lt;button onClick = \"deixarVermelho()\"&gt;\n      Deixar vermelho\n    &lt;/button&gt;\n    &lt;script src = \"script.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n# JS (script.js)\ndeixarVermelho = function() {\n  document.getElementById(\"alvo\").style = \"color: red\";\n}\n\nO código JS nesse exemplo define uma função que muda o atributo style do elemento com id alvo. Essa função é chamada sempre que o botão é clicado. Isso acontece porque associamos a função ao evento onClick do botão.\nEm um aplicativo Shiny, o procedimento é equivalente. A grande diferença é que o arquivo script.js deve estar dentro da pasta www/ para ser acessado pelo navegador.\n\n# Definiindo o código JS diretamente na UI\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  tags$p(\"Parágrafo 1\", id = \"alvo\"),\n  tags$p(\"Parágrafo 2\"),\n  tags$button(onClick = \"deixarVermelho()\", \"Deixar vermelho\"),\n  tags$script(\n    'deixarVermelho = function() {\n      document.getElementById(\"alvo\").style = \"color: red\";\n    }'\n  )\n)\n\nserver &lt;- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n\n\n# Definindo o código JS em um arquivo externo (www/script.js)\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  tags$p(\"Parágrafo 1\", id = \"alvo\"),\n  tags$p(\"Parágrafo 2\"),\n  tags$button(onClick = \"deixarVermelho()\", \"Deixar vermelho\"),\n  tags$script(src = \"script.js\")\n)\n\nserver &lt;- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n\nUm ponto de atenção sobre a utilização de códigos JS em documentos HTML é a posição onde eles são definidos dentro do documento. Como o HTML é interpretado pelo navegador na ordem em que o código foi escrito, se um elemento &lt;script&gt; utilizar elementos que ainda não foram criados, o código JS não vai funcionar.\nNo exemplo anterior, poderíamos definir o código JavaScript em qualquer lugar do script pois ele define uma função que só será usada quando o botão for clicado. No exemplo a seguir, o código JavaScript pinta de vermelho todos os parágrafos com classe vermelho. Para que isso seja possível, o elemento script deve vir após a criação dos elementos p. Se estivesse definido antes dos elementos p, nenhum parágrafo ficaria vermelho.\n\n# Os parágrafos 1, 3 e 5 ficam com cor vermelha\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  tags$p(\"Parágrafo 1\", class = \"vermelho\"),\n  tags$p(\"Parágrafo 2\"),\n  tags$p(\"Parágrafo 3\", class = \"vermelho\"),\n  tags$p(\"Parágrafo 4\"),\n  tags$p(\"Parágrafo 5\", class = \"vermelho\"),\n  tags$script(\n    'document.getElementsByClassName(\"vermelho\").forEach(\n      function(paragrafo) {\n        paragrafo.style = \"color: red\"\n      }\n    )'\n  )\n)\n\nserver &lt;- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n\n\n# Nenhum parágrafo fica vermelho pois o código JS\n# vem antes da criação do parágrafo\nlibrary(shiny)\n\nui &lt;- fluidPage(\n   tags$script(\n    'document.getElementsByClassName(\"vermelho\").forEach(\n      function(paragrafo) {\n        paragrafo.style = \"color: red\"\n      }\n    )'\n  ),\n  tags$p(\"Parágrafo 1\", class = \"vermelho\"),\n  tags$p(\"Parágrafo 2\"),\n  tags$p(\"Parágrafo 3\", class = \"vermelho\"),\n  tags$p(\"Parágrafo 4\"),\n  tags$p(\"Parágrafo 5\", class = \"vermelho\")\n)\n\nserver &lt;- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n\n\n\n12.3.2 Interagindo com inputs via JavaScript\nNesta seção, vamos discutir como interagir com os inputs do Shiny a partir do JavaScript. Vamos fazer isso de duas maneiras: acessando o valor de inputs criados pela UI e criar novos inputs via JavaScript.\nPara acessar o valor de um input criado na UI do Shiny a partir do JavaScript precisamos primeiro saber qual elemento HTML representa esse input. No caso de um selectInput com inputId = seletor, por exemplo, estamos criando no HTML um elemento &lt;select id = \"seletor\"&gt;. Então, se quisermos acessar o valor desse input via JS, basta buscarmos por esse elemento e extrair o seu valor.\nNo exemplo a seguir, constuimos um app que permite trocar a cor do texto apresentado a partir de um selectInput. Essa troca é feita apenas no navegador, a partir de um código JavaScript. Tente rodar o app para testar testar esse comportamento.\n\n# app.R\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  h1(\"JavaScript\", align = \"center\"),\n  hr(),\n  selectInput(\n    inputId = \"cor_do_texto\",\n    label = \"Selecione a cor do texto\",\n    choices = c(\"black\", \"red\", \"orange\", \"purple\", \"blue\", \"green\")\n  ),\n  br(),\n  p(\"JavaScript (frequentemente abreviado como JS) é uma linguagem de\n    programação interpretada estruturada, de script em alto nível com tipagem\n    dinâmica fraca e multiparadigma (protótipos, orientado a objeto,\n    imperativo e funcional). Juntamente com HTML e CSS, o JavaScript é\n    uma das três principais tecnologias da World Wide Web. JavaScript\n    permite páginas da Web interativas e, portanto, é uma parte essencial\n    dos aplicativos da web. A grande maioria dos sites usa, e todos os\n    principais navegadores têm um mecanismo JavaScript dedicado para\n    executá-lo.\"),\n  p(\"É atualmente a principal linguagem para programação client-side em\n    navegadores web. É também bastante utilizada do lado do servidor através\n    de ambientes como o node.js.\"),\n  tags$script(src = \"script.js\")\n)\n\nserver &lt;- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)\n\n\n# www/script.js\nvar select = document.getElementById(\"cor_do_texto\");\n\nselect.onchange = function() {\n  var paragrafos = document.getElementsByTagName(\"p\");\n  for (var i = 0; i &lt; paragrafos.length; i++) {\n    paragrafos[i].style = \"color: \" + select.value + \";\";\n  }\n}\n\n\nO código JavaScript utilizado busca no HTML o elemento que representa o selectInput a partir do seu Id e atribui a ele uma função que será executada sempre que o valor desse select mudar. A função busca por todas as tags p do HTML e utiliza o valor do select para alterar a cor do texto. Esse valor é acessado via a propriedade value do objeto select.\nComo exercício, tente refazer esse exemplo sem usar o JavaScript, usando no lugar um renderUI na função server.\nA partir do JavaScript, também podemos criar novos inputs e acessá-los no servidor. Para isso, usamos o método Shiny.setInputValue(idName, value) em nosso código JavaScript. O app abaixo apresenta uma mensagem na tela informando qual navegador está sendo usado para acessá-lo. Veja que o input$browser não é definido na UI, mas sim dentro do código JavaScript.\n\n# app.R\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  tags$script(src = \"script.js\"),\n  textOutput(\"mensagem\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  output$mensagem &lt;- renderText({\n    print(input$browser)\n    glue::glue(\"Olá! Você está usando o navegador {input$browser}!\")\n  })\n\n}\n\nshinyApp(ui, server)\n\n\n// www/script.js\nfunction getBrowserName() {\n  let browserInfo = navigator.userAgent;\n  let browser;\n  if (browserInfo.includes('Opera') || browserInfo.includes('Opr')) {\n    browser = 'Opera';\n  } else if (browserInfo.includes('Edg')) {\n    browser = 'Edge';\n  } else if (browserInfo.includes('Chrome')) {\n    browser = 'Chrome';\n  } else if (browserInfo.includes('Safari')) {\n    browser = 'Safari';\n  } else if (browserInfo.includes('Firefox')) {\n    browser = 'Firefox';\n  } else {\n    browser = 'unknown';\n  }\n    return browser;\n}\n\n$(document).on(\"shiny:sessioninitialized\", function() {\n  Shiny.setInputValue(\"browser\", getBrowserName());\n});\n\n\nA primeira parte do código JavaScript define uma função chamada getBrowserName(), que identifica qual o navegador está sendo utilizado. A segunda parte define uma função anônima que será executada assim que a sessão do Shiny for inicializada. Essa função cria o input browser com o valor retornado pela função getBrowserName().\nO objeto Shiny possui vários outros métodos para interagirmos com a sessão do Shiny via JavaScript. Recomendamos a leitura dos artigos a seguir para mais informações de como utilizá-lo:\n\nComunicando-se com o Shiny via JS\nEventos JS no Shiny",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>HTML, CSS e JavaScript</span>"
    ]
  },
  {
    "objectID": "html-css-js.html#exercícios",
    "href": "html-css-js.html#exercícios",
    "title": "12  HTML, CSS e JavaScript",
    "section": "12.4 Exercícios",
    "text": "12.4 Exercícios\n1 - O que são elementos HTML?\n\n2 - Para que serve a seção &lt;head&gt; de um código HTML?\n\n3 - Conserte o erro do código HTML abaixo:\n\n&lt;p&gt; Para acessar a loja, basta clicar &lt;a href = \"https://loja.curso-r.com\"&gt;neste link&lt;/p&gt;&lt;/a&gt;\n\n\n4 - Qual a diferença entre as tags &lt;div&gt; e &lt;span&gt;?\n\n5 - Ao que se refere o termo cascading da sigla CSS?\n\n6 - Qual a ordem de precedência com relação ao local onde CSS pode ser colocado (inline, interno, externo)?\n\n7 - O que é o box model no CSS?\n\n8 - Segundo o código CSS abaixo, a caixa azul vai aparecer sobre o fundo amarelo ou rosa? E a caixa laranja?\n\n&lt;div style = \"position: relative;\"&gt;\n  &lt;div style = \"height: 100px; background-color: yellow;\"&gt;&lt;/div&gt;\n  &lt;div style = \"height: 100px; background-color: pink;\"&gt;\n    &lt;div style = \"height: 40px; width: 10%; background-color: blue;\"&gt;\n      Caixa azul\n    &lt;/div&gt;\n    &lt;div style = \"height: 40px; width: 10%; background-color: orange; position: absolute; top: 0px;\"&gt;\n      Caixa laranja\n    &lt;/div&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n\n\n9 - Reproduza a página HTML contida neste link. Sinta-se livre para deixar o visual da página da sua maneira.\n\n10 - Em um app Shiny, para que serve o método JS Shiny.setInputValue(idName, value)?",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>HTML, CSS e JavaScript</span>"
    ]
  },
  {
    "objectID": "html-css-js.html#footnotes",
    "href": "html-css-js.html#footnotes",
    "title": "12  HTML, CSS e JavaScript",
    "section": "",
    "text": "É uma boa prática declarar o idioma da página, pois isso é utilizado pelos algorítmos de busca e pelos navegadores.↩︎",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>HTML, CSS e JavaScript</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-2.html",
    "href": "shiny-na-pratica-2.html",
    "title": "13  Shiny na prática II",
    "section": "",
    "text": "13.1 Caixas de diálogo",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Shiny na prática II</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-2.html#tooltips",
    "href": "shiny-na-pratica-2.html#tooltips",
    "title": "13  Shiny na prática II",
    "section": "13.2 Tooltips",
    "text": "13.2 Tooltips\nTooltips são uma ótima maneira de se comunicar com a pessoa utilizando o seu app. Elas permitem passar todo tipo de informação extra e não ocupam espaço da UI.\nEssencialmente, elas são textos que só aparecem quando passamos o ponteiro do mouse em algum elemento da tela. Por exemplo, passe o mouse em cima da frase a seguir:\n\n\n\n\n\n\n\nExistem várias soluções disponíveis para incluirmos tooltips em um aplicativo Shiny, entre elas o pacote tippy.\nEsse pacote está no CRAN, então basta rodar o código abaixo para instalá-lo:\n\ninstall.packages(\"tippy\")\n\nPara colocar uma tooltip em um elemento do seu app, basta usar a função tippy::with_tippy().\n\ntippy::with_tippy(\n  numericInput(\n    \"tamanho\",\n    label = \"Selecione o tamanho da amostra\",\n    value = 1000,\n    step = 1000\n  ),\n  tooltip = \"Amostra de uma distribuição Normal com média 0 e variância 100.\"\n)\n\n\n\n\n\n\n\n\n\n\nPara aplicar a mesma tooltip a vários elementos, utilize a função tippy::tippy_class().\n\nfluidRow(\n  column(\n    width = 4,\n    div(\n      class = \"valuebox-tip\",\n      shinydashboard::valueBoxOutput(\"valor_1\", width = 12)\n    )\n  ),\n  column(\n    width = 4,\n    div(\n      class = \"valuebox-tip\",\n      shinydashboard::valueBoxOutput(\"valor_2\", width = 12)\n    )\n  ),\n  column(\n    width = 4,\n    div(\n      class = \"valuebox-tip\",\n      shinydashboard::valueBoxOutput(\"valor_3\", width = 12)\n    )\n  ),\n  column(\n    width = 12,\n    plotOutput(\"grafico\")\n  ),\n  tippy::tippy_class(\n    \"valuebox-tip\",\n    content = \"Você precisa importar o css do pacote shinydashboard se quiser usar valueBoxes fora do shinydashboard.\"\n  )\n)\n\n\n\n\n\n\n\n\n\n\nVocê pode customizar a tooltip seguindo os parâmetros da documentação oficial da biblioteca tippy.js.\n\ntippy::tippy_class(\n  \"valuebox-tip\",\n  content = \"Você precisa importar o css do pacote shinydashboard se quiser usar valueBoxes fora do shinydashboard.\",\n  arrow = TRUE,\n  placement = \"left\"\n)\n\n\n\n\n\n\n\n\n\n\nOs fragmentos de código acima pertencem ao app a seguir. Rode o app para ver as tooltips em funcionamento.\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  shinyWidgets::useShinydashboard(),\n  titlePanel(\"Usando tooltips\"),\n  sidebarLayout(\n    sidebarPanel(\n      tippy::with_tippy(\n        numericInput(\n          \"tamanho\",\n          label = \"Selecione o tamanho da amostra\",\n          value = 1000,\n          step = 1000\n        ),\n        tooltip = \"Amostra de uma distribuição Normal com média 0 e variância 100.\"\n      )\n    ),\n    mainPanel(\n      fluidRow(\n        column(\n          width = 4,\n          div(\n            class = \"valuebox-tip\",\n            shinydashboard::valueBoxOutput(\"valor_1\", width = 12)\n          )\n        ),\n        column(\n          width = 4,\n          div(\n            class = \"valuebox-tip\",\n            shinydashboard::valueBoxOutput(\"valor_2\", width = 12)\n          )\n        ),\n        column(\n          width = 4,\n          div(\n            class = \"valuebox-tip\",\n            shinydashboard::valueBoxOutput(\"valor_3\", width = 12)\n          )\n        ),\n        column(\n          width = 12,\n          plotOutput(\"grafico\")\n        ),\n        tippy::tippy_class(\n          \"valuebox-tip\",\n          content = \"Você precisa importar o css do pacote shinydashboard se quiser usar valueBoxes fora do shinydashboard.\",\n          arrow = TRUE,\n          placement = \"left\"\n        )\n      )\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  \n  amostra &lt;- reactive(rnorm(input$tamanho, sd = 10))\n  \n  output$valor_1 &lt;- shinydashboard::renderValueBox({\n    shinydashboard::valueBox(\n      value = round(mean(amostra()), 1),\n      subtitle = \"Média dos valores\",\n      icon = icon(\"info-circle\")\n    )\n  })\n  \n  output$valor_2 &lt;- shinydashboard::renderValueBox({\n    shinydashboard::valueBox(\n      value = round(var(amostra()), 1),\n      subtitle = \"Variância dos valores\",\n      icon = icon(\"info-circle\")\n    )\n  })\n  \n  output$valor_3 &lt;- shinydashboard::renderValueBox({\n    shinydashboard::valueBox(\n      value = round(sd(amostra()), 1),\n      subtitle = \"Desvio-padrão dos valores\",\n      icon = icon(\"info-circle\")\n    )\n  })\n  \n  output$grafico &lt;- renderPlot(hist(amostra()))\n  \n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Shiny na prática II</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-2.html#seletor-de-visualizações",
    "href": "shiny-na-pratica-2.html#seletor-de-visualizações",
    "title": "13  Shiny na prática II",
    "section": "13.3 Seletor de visualizações",
    "text": "13.3 Seletor de visualizações\nNesta seção, vamos mostrar como usar o widget radioGroupButtons do pacote shinyWidgets para construir um app com seletor de visualizações, isto é, botões que mudam o tipo de visualização apresentada na tela.\nComo exemplo, vamos construir um shiny app que mostra um gráfico de barras, um gráfico de linhas ou uma tabela (a depender da escolha da pessoa que estiver usando) do número de gols do Brasileirão1 por temporada.\nO primeiro passo é configurar o widget corretamente. Veja abaixo que o segredo é utilizar os argumentos choiceValues e choiceNames. Para o primeiro, passamos os valores que serão acessados dentro do server a depender da escolha na UI (equivalente ao argumento choices). Ao segundo, podemos passar tanto textos (que seriam escritos dentro do botão) quanto ícones. Nesse caso, utilizamos ícones da biblioteca Font Awesome, com ajuda da função shiny::icon(). Repare também que deixamos o tamanho dos botões um pouco maiores com o argumento size = \"lg\".\n\nshinyWidgets::radioGroupButtons(\n  inputId = \"vis_escolhida\",\n  label = \"\",\n  choiceValues = c(\"barras\", \"linhas\", \"tabela\"),\n  choiceNames = list(\n    icon(\"bar-chart\"),\n    icon(\"line-chart\"),\n    icon(\"table\")\n  ),\n  size = \"lg\",\n  selected = \"barras\"\n)\n\nAgora, precisamos construir a lógica do Output, tanto na UI como no server. Como a nossa visualização pode gerar gráficos ou uma tabela, precisaremos de funções *Output() e render*() diferentes. Dessa forma, vamos utilizar na nossa UI um OutputUI().\n\n# A nossa UI ficará assim\nui &lt;- fluidPage(\n  fluidRow(\n    column(\n      width = 12,\n      h1(\"App com seletor de visualizações\")\n    )\n  ),\n  br(),\n  fluidRow(\n    column(\n      offset = 1,\n      width = 11,\n      shinyWidgets::radioGroupButtons(\n        inputId = \"vis_escolhida\",\n        label = \"\",\n        choiceValues = c(\"barras\", \"linhas\", \"tabela\"),\n        choiceNames = list(\n          icon(\"bar-chart\"),\n          icon(\"line-chart\"),\n          icon(\"table\")\n        ),\n        size = \"lg\",\n        selected = \"barras\"\n      )\n    )\n  ),\n  br(),\n  fluidRow(\n    column(\n      width = 12,\n      uiOutput(\"vis\")\n    )\n  )\n)\n\nAgora, no server, podemos criar funções *Output() diferentes a depender da visualização escolhida. Usamos plotOutput() para os gráficos e reactable::reactableOutput() para a tabela.\n\noutput$vis &lt;- renderUI({\n  if (input$vis_escolhida %in% c(\"barras\", \"linhas\")) {\n    plotOutput(\"grafico\")\n  } else if (input$vis_escolhida == \"tabela\") {\n    reactable::reactableOutput(\"tabela\")\n  }\n})\n\nAgora vamos construir nossas visualizações. Primeiro, vamos montar a base que precisamos para gerar tanto os gráficos quanto a tabela.\nOs dados vêm do pacote brasileirao. Se você não possui esse pacote instalado, basta rodar o código abaixo:\n\ninstall.packages(\"remotes\")\nremotes::install_github(\"williamorim/brasileirao\")\n\nComo a tabela que gera os gráficos não depende de nenhum valor ou expressão reativa, podemos colocar o código que a gera diretamente no server.\n\ntab &lt;- brasileirao::matches |&gt;\n  dplyr::filter(\n    score != \"x\",\n    season %in% 2006:2020\n  ) |&gt;\n  tidyr::separate(\n    score,\n    c(\"gols_casa\", \"gols_visitante\"),\n    sep = \"x\",\n    convert = TRUE\n  ) |&gt;\n  dplyr::mutate(\n    gols = gols_casa + gols_visitante\n  ) |&gt;\n  dplyr::group_by(season) |&gt;\n  dplyr::summarise(gols = sum(gols))\n\nPara gerar os gráficos, só precisamos de um renderPlot() e um if/else para devolver o gráfico certo.\n\noutput$grafico &lt;- renderPlot({\n  \n  grafico_base &lt;- tab |&gt;\n    ggplot(aes(x = season, y = gols)) +\n    labs(x = \"Temporada\", y = \"Número de gols\") +\n    theme_minimal() +\n    ggtitle(\"Número de gols do Brasileirão por temporada\")\n  \n  if (input$vis_escolhida == \"linhas\") {\n    grafico_base +\n      geom_line(color = \"dark green\")\n  } else if (input$vis_escolhida == \"barras\") {\n    grafico_base +\n      geom_col(width = 0.5, fill = \"dark green\")\n  }\n})\n\nPara gerar a tabela, precisamos apenas de um renderReactable().\n\noutput$tabela &lt;- reactable::renderReactable({\n  tab |&gt;\n    reactable::reactable(\n      fullWidth = FALSE,\n      columns = list(\n        season = reactable::colDef(\n          name = \"Temporada\"\n        ),\n        gols = reactable::colDef(\n          name = \"Número de gols\"\n        )\n      )\n    )\n})\n\nJuntando tudo, temos o app a seguir:\n\nlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(\n      width = 12,\n      h1(\"App com seletor de visualizações\")\n    )\n  ),\n  br(),\n  fluidRow(\n    column(\n      offset = 1,\n      width = 11,\n      shinyWidgets::radioGroupButtons(\n        inputId = \"vis_escolhida\",\n        label = \"\",\n        choiceValues = c(\"barras\", \"linhas\", \"tabela\"),\n        choiceNames = list(\n          icon(\"bar-chart\"),\n          icon(\"line-chart\"),\n          icon(\"table\")\n        ),\n        size = \"lg\",\n        selected = \"barras\"\n      )\n    )\n  ),\n  br(),\n  fluidRow(\n    column(\n      width = 12,\n      uiOutput(\"vis\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n\n  output$vis &lt;- renderUI({\n    if (input$vis_escolhida %in% c(\"barras\", \"linhas\")) {\n      plotOutput(\"grafico\")\n    } else if (input$vis_escolhida == \"tabela\") {\n      reactable::reactableOutput(\"tabela\")\n    }\n  })\n\n  tab &lt;- brasileirao::matches |&gt;\n    dplyr::filter(\n      score != \"x\",\n      season %in% 2006:2020\n    ) |&gt;\n    tidyr::separate(\n      score,\n      c(\"gols_casa\", \"gols_visitante\"),\n      sep = \"x\",\n      convert = TRUE\n    ) |&gt;\n    dplyr::mutate(\n      gols = gols_casa + gols_visitante\n    ) |&gt;\n    dplyr::group_by(season) |&gt;\n    dplyr::summarise(gols = sum(gols))\n\n  output$grafico &lt;- renderPlot({\n\n    grafico_base &lt;- tab |&gt;\n      ggplot(aes(x = season, y = gols)) +\n      labs(x = \"Temporada\", y = \"Número de gols\") +\n      theme_minimal() +\n      ggtitle(\"Número de gols do Brasileirão por temporada\")\n\n    if (input$vis_escolhida == \"linhas\") {\n      grafico_base +\n        geom_line(color = \"dark green\")\n    } else if (input$vis_escolhida == \"barras\") {\n      grafico_base +\n        geom_col(width = 0.5, fill = \"dark green\")\n    }\n  })\n\n  output$tabela &lt;- reactable::renderReactable({\n    tab |&gt;\n      reactable::reactable(\n        fullWidth = FALSE,\n        columns = list(\n          season = reactable::colDef(\n            name = \"Temporada\"\n          ),\n          gols = reactable::colDef(\n            name = \"Número de gols\"\n          )\n        )\n      )\n  })\n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Shiny na prática II</span>"
    ]
  },
  {
    "objectID": "shiny-na-pratica-2.html#footnotes",
    "href": "shiny-na-pratica-2.html#footnotes",
    "title": "13  Shiny na prática II",
    "section": "",
    "text": "Campeonato Brasileiro de futebol da Série A.↩︎",
    "crumbs": [
      "Parte 2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Shiny na prática II</span>"
    ]
  },
  {
    "objectID": "referencias.html",
    "href": "referencias.html",
    "title": "Referências",
    "section": "",
    "text": "Abaixo, listamos as referências utilizadas na construção deste livro.\n\nProgramação em R\n\nCiência de Dados em R, da Curso-R\nR for Data Sciente, do Garrett Grolemund e Hadley Wickham\nAdvanced R, do Hadley Wickham\nR packages, do Hadley Wickham\n\n\n\nShiny\n\nMastering Shiny, do Hadley Wickham\nEngineering Shiny, do Colin Fay, Sébastien Rochette, Vincent Guyader e Cervan Girard.",
    "crumbs": [
      "Referências"
    ]
  }
]